[TOC]

## 函数&数组的扩展

### 函数的扩展

#### 1 函数参数的默认值

- ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 缺点在于：如果参数`y`赋值了，但是对应的布尔值为`false`，则该赋值不起作用。 

- ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 

  ```javascript
  function log(x, y = 'World') {
    console.log(x, y);
  }
  
  log('Hello') // Hello World
  log('Hello', 'China') // Hello China
  log('Hello', '') // Hello
  ```

- 【好处】，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化 

- 参数变量`x`是默认声明的，在函数体中，不能用`let`或`const`再次声明，否则会报错。 

- 使用参数默认值时，函数不能有同名参数。 

- 参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。 

##### 1.1 **与解构赋值默认值结合使用**

```JavaScript
function foo({x, y = 5} = {}) {
  console.log(x, y);
}
foo() // undefined 5
```

作为练习，请问下面两种写法有什么差别？ 

```JavaScript
// 写法一，函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二，函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]
```

##### 1.2**参数默认值的位置**

通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。**如果非尾部的参数设置默认值，是没法省略的，**除非显式输入`undefined` 。 

```JavaScript
function f(x = 1, y) {
  return [x, y];
}
f() // [1, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [1, 1]
```

##### 1.3**函数的length属性**

指定了默认值以后，函数的`length`属性，将**返回没有指定默认值的参数个数**。 

```JavaScript
(function (a, b, c = 5) {}).length // 2
//length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。
```

如果设置了默认值的参数不是尾参数，那么`length`属性也不再计入后面的参数了。 

```JavaScript
(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1
```

##### 1.4 作用域

一旦设置了参数的默认值，函数进行声明初始化时，**参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失**。这种语法行为，在不设置参数默认值时，是不会出现的。 

**下面是一个更复杂的例子。**

```JavaScript
var x = 1;
function foo(x, y = function() { x = 2; }) {
  var x = 3;
  y();
  console.log(x);
}
foo() // 3，函数foo的参数形成一个单独作用域，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量
x // 1
```

```JavaScript
var x = 1;
function foo(x, y = function() { x = 2; }) {
  x = 3;
  y();
  console.log(x);
}

foo() // 2，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。
x // 1
```

##### **1.5 应用**

利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。 

另外，可以将参数默认值设为`undefined`，表明这个参数是可以省略的。

```JavaScript
function foo(optional = undefined) { ··· }
```

#### 2 rest 参数

ES6 引入 rest 参数（形式为`...变量名`），用于获取函数的多余参数，这样就不需要使用`arguments`对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 

- 利用 rest 参数，可以向该函数传入任意数目的参数。 function add(...values){}
- 注意，rest 参数之后不能再有其他参数（即**只能是最后一个参数**），否则会报错。 
- 函数的`length`属性，不包括 rest 参数。 

#### 3 严格模式

- ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 
- ，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。 
- 两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。 
- 第二种是把函数包在一个无参数的立即执行函数里面。 

#### 4 name 属性

- 函数的`name`属性，返回该函数的函数名。 
- ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的`name`属性，会返回空字符串，而 ES6 的`name`属性会返回实际的函数名。 
- `Function`构造函数返回的函数实例，`name`属性的值为`anonymous`。 (new Function).name // "anonymous"
- `bind`返回的函数，`name`属性值会加上`bound`前缀。 foo.bind({}).name // "bound foo"

#### 5 箭头函数

- ES6 允许使用“箭头”（`=>`）定义函数。 
- 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 var f = () => 5;   var f = function () { return 5 };
- 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用`return`语句返回。 
- 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 let getTempItem = id => ({ id: id, name: "Temp" });

【注意】

- （1）函数体内的**`this`对象，就是定义时所在的对象**，而不是使用时所在的对象。（`this`对象的指向是可变的，但是在箭头函数中，它是固定的。 箭头函数可以让`setTimeout`里面的`this`，绑定定义时所在的作用域，而不是指向运行时所在的作用域。 ）

  （2）不可以当作构造函数，也就是说，**不可以使用`new`命令**，否则会抛出一个错误。

  （3）**不可以使用`arguments`对象**，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

  （4）**不可以使用`yield`命令**，因此箭头函数不能用作 Generator 函数。

  - `this`指向的固定化，并不是因为箭头函数内部有绑定`this`的机制，实际原因是箭头函数根本没有自己的`this`，导致内部的`this`就是外层代码块的`this`。正是因为它没有`this`，所以也就不能用作构造函数。 
  - 由于箭头函数没有自己的`this`，所以当然也就不能用`call()`、`apply()`、`bind()`这些方法去改变`this`的指向。 

【不适用场合】

1. 第一个场合是定义对象的方法，且该方法内部包括`this`。 
2. 需要动态`this`的时候，也不应使用箭头函数。 

【嵌套的箭头函数】

- 箭头函数内部，还可以再使用箭头函数。 

- ？箭头函数还有一个功能，就是可以很方便地改写 λ 演算。 

  ```JavaScript
  // λ演算的写法
  fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))
  
  // ES6的写法
  var fix = f => (x => f(v => x(x)(v)))
                 (x => f(v => x(x)(v)));
  ```

#### 6 尾调用优化

##### 6.1 什么是尾调用（Tail Call） 

- 指某个函数的最后一步是调用另一个函数 function f(x){  return g(x);}

##### 6.2 尾调用优化

函数调用会在内存形成一个“调用记录”，又称**“调用帧”（call frame）**，保存调用位置和内部变量等信息。 

如果在函数`A`的内部调用函数`B`，那么在`A`的调用帧上方，还会形成一个`B`的调用帧。等到`B`运行结束，将结果返回到`A`，`B`的调用帧才会消失。如果函数`B`内部还调用函数`C`，那就还有一个`C`的调用帧，以此类推。所有的调用帧，就形成一个**“调用栈”（call stack）**。 

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要**直接用内层函数的调用帧，取代外层函数的调用帧就可以了**。 

**这将大大节省内存。这就是“尾调用优化”的意义。** 

【注意】只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 

##### 6.3 尾递归

函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 

递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生**“栈溢出”错误（stack overflow）**。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 

尾递归优化过的 Fibonacci 数列实现如下。

```JavaScript
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
```

##### 6.4 递归函数的改写

确保最后一步只调用自身。做到这一点的方法，就是**把所有用到的内部变量改写成函数的参数。** 

函数式编程有一个概念，叫做**柯里化（currying）**，意思是将多参数的函数转换成单参数的形式。 采用 ES6 的函数默认值 可以简单实现。

##### 6.5 严格模式

- ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 

  因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。

  - `func.arguments`：返回调用时函数的参数。
  - `func.caller`：返回调用当前函数的那个函数。

##### 6.6 尾递归优化的实现

原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。 

怎么做可以减少调用栈呢？就是**采用“循环”换掉“递归”。** 

？**蹦床函数（trampoline）**可以将递归执行转为循环执行。 

```JavaScript
function trampoline(f) {
  while (f && f instanceof Function) {
    f = f();
  }
  return f;
}
//注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。
```

#### 7 函数参数的尾逗号

ES2017 [允许](https://github.com/jeffmo/es-trailing-function-commas)函数的最后一个参数有尾逗号（trailing comma） 。





### 数组的扩展

#### 1 扩展运算符（spread） 

- 三个点（`...`）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 

- 主要用于函数调用 

  ```JavaScript
  function add(x, y) {
    return x + y;
  }
  
  const numbers = [4, 38];
  add(...numbers) // 42
  ```

- 注意，扩展运算符如果放在括号中，JavaScript 引擎就会认为这是函数调用。如果这时不是函数调用，就会报错。 

- 可以替代函数的apply方法：f.apply(null, args);  →  f(...args);

- 通过`push`函数，将一个数组添加到另一个数组的尾部。 arr1.push(...arr2);

##### 1.1 扩展运算符的作用

**（1）复制数组** ：`a2`都是`a1`的克隆。 

```JavaScript
const a1 = [1, 2];
// 写法一
const a2 = [...a1];
// 写法二
const [...a2] = a1;
```

**（2）合并数组**： [...arr1, ...arr2, ...arr3] ——浅拷贝

**（3）与解构赋值结合** 

扩展运算符可以与解构赋值结合起来，用于生成数组。

```JavaScript
// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list
```

如果将扩展运算符用于数组赋值，**只能放在参数的最后一位，否则会报错。** 

**（4）字符串** 

扩展运算符还可以将字符串转为真正的数组。

```JavaScript
[...'hello']// [ "h", "e", "l", "l", "o" ]
'x\uD83D\uDE80y'.length // 4
[...'x\uD83D\uDE80y'].length // 3，能够正确识别四个字节的 Unicode 字符
```

**（5）？实现了 Iterator 接口的对象** 

任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。 

**（6）？Map 和 Set 结构，Generator 函数** 

#### 2 Array.from()

`Array.from`方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 

```JavaScript
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};
// ES5的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']
// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
```

`Array.from`还可以接受第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 Array.from([1, 2, 3], (x) => x * x)// [1, 4, 9]

如果`map`函数里面用到了`this`关键字，还可以传入`Array.from`的第三个参数，用来绑定`this`。 Array.from({ length: 2 }, () => 'jack')// ['jack', 'jack']

#### 3 Array.of()

`Array.of`方法用于将一组值，转换为数组。 Array.of(3, 11, 8) // [3,11,8]

`Array`方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，`Array()`才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 

`Array.of`总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 

#### 4 数组实例的 copyWithin()

数组实例的`copyWithin`方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。**会修改当前数组。** 

```JavaScript
[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]，上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。
```



#### 5 数组实例的 find() 和 findIndex()

数组实例的`find`方法，用于找出第一个符合条件的数组成员。它的**参数是一个回调函数**，所有数组成员依次执行该回调函数，直到**找出第一个**返回值为`true`的成员，然后返回该成员。如果没有符合条件的成员，则返回`undefined`。 

```JavaScript
[1, 5, 10, 15].find(function(value, index, arr) {
  return value > 9;
}) // 10，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。
```

数组实例的`findIndex`方法的用法与`find`方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1`。 

```JavaScript
[1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value > 9;
}) // 2
```

这两个方法都可以接受第二个参数，用来绑定回调函数的`this`对象。

```JavaScript
function f(v){
  return v > this.age;
}
let person = {name: 'John', age: 20};
[10, 12, 26, 15].find(f, person);    // 26，接收了第二个参数person对象，回调函数中的this对象指向person对象。
```

另外，这两个方法都可以发现`NaN`，弥补了数组的`indexOf`方法的不足。[NaN].findIndex(y => Object.is(NaN, y))// 0 



#### 6 数组实例的 fill()

`fill`方法使用给定值，填充一个数组。 

```JavaScript
new Array(3).fill(7)
// [7, 7, 7]，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。
```

`fill`方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 

【注意】如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。 

```JavaScript
let arr = new Array(3).fill({name: "Mike"});
arr[0].name = "Ben";
arr
// [{name: "Ben"}, {name: "Ben"}, {name: "Ben"}]，同一个对象
```



#### 7 数组实例的 entries()，keys() 和 values()

ES6 提供三个新的方法——`entries()`，`keys()`和`values()`——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用`for...of`循环进行遍历，唯一的区别是`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历。 

```JavaScript
for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"
```

如果不使用`for...of`循环， 可以手动调用遍历器对象的`next`方法，进行遍历 

#### 8 数组实例的 includes()

`Array.prototype.includes`方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的`includes`方法类似。 [1, 2, NaN].includes(NaN) // true

该方法的第二个参数表示搜索的起始位置，默认为`0`。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为`-4`，但数组长度为`3`），则会重置为从`0`开始。 

**与`indexOf`方法** ：`indexOf`方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于`-1`，表达起来不够直观。二是，它内部使用严格相等运算符（`===`）进行判断，这会导致对`NaN`的误判。 

#### 9 数组实例的 flat()，flatMap()

- `Array.prototype.flat()`用于将嵌套的数组“拉平”，变成一维的数组。该方法**返回一个新数组**，对原数据没有影响。 [1, 2, [3, 4]].flat()// [1, 2, 3, 4]

`flat()`**默认只会“拉平”一层**，如果想要“拉平”多层的嵌套数组，可以将`flat()`方法的参数写成一个整数，表示想要拉平的层数，默认为1。 

如果不管有多少层嵌套，都要转成一维数组，可以用`Infinity`关键字作为参数。 [1, [2, [3]]].flat(Infinity)// [1, 2, 3]

如果原数组有空位，`flat()`方法会跳过空位。 [1, 2, , 4, 5].flat()// [1, 2, 4, 5]

- `flatMap()`方法对原数组的每个成员执行一个函数（相当于执行`Array.prototype.map()`），然后对返回值组成的数组执行`flat()`方法。该方**法返回一个新数组**，不改变原数组。 

- ```JavaScript
  //只能展开一层数组， // 相当于 [[2, 4], [3, 6], [4, 8]].flat()
  [2, 3, 4].flatMap((x) => [x, x * 2])
  // [2, 4, 3, 6, 4, 8]
  ```

`flatMap()`方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。 

```JavaScript
arr.flatMap(function callback(currentValue[, index[, array]]) {
  // ...flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this。
}[, thisArg])
```

#### 10 数组的空位

数组的空位指，数组的某一个位置没有任何值。 

**注意，**空位不是`undefined`，一个位置的值等于`undefined`，依然是有值的。空位是没有任何值 

ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。

- `forEach()`, `filter()`, `reduce()`, `every()` 和`some()`都会跳过空位。
- `map()`会跳过空位，但会保留这个值
- `join()`和`toString()`会将空位视为`undefined`，而`undefined`和`null`会被处理成空字符串。

ES6 则是明确将空位转为`undefined`。 

