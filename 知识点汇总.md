[TOC]

# 面试题汇总

## **HTML 相关**

### --- 浏览器内核

- Trident：IE、360、搜狗 ,  -ms代表ie内核识别码
- Webkit：chrome、Safari，-webkit代表苹果的Safari浏览器及谷歌内核识别码
- Geoko：Firefox，-moz代表火狐内核识别码
- presto：Opera，-o代表欧朋【opera】内核识别码

### ---  [浏览器的兼容](https://blog.csdn.net/gaoqiang1112/article/details/77891969)

随便说个4、5个

- 浏览器默认的内外边距不同，解决：*{margin：0；padding：0}
- 移动端的1像素问题
- table td 自动换行
- IE6：css属性前加 `_`#id{ _display:block;}；ie 7：css属性前加`*`   #id{*display:block;}；IE8：id{margin-top:10px 9;/*IE8*/} 在网站设计CSS属性后分号前加上空格与斜线并加入一个数字9。
- 几个img标签放在一起的时候，有些浏览器会有默认的间距，通配符也不起作用：使用float属性为img布局

### --- html5 新特性

- 新增了标签canvas绘图、地图
- 新增语义化标签：header、footer、section、aside、article等
- 本地存储：localstorage、sessionStorage
- 表单控件
- b -> strong加粗 ; i -> em; s -> del; u -> ins; sub下标 ； sup上标；center 居中；font字体

**html5兼容性问题**，IE6\7\8等不能使用header等标签

- 自己创建自定义标签，createElement，然后设置样式

- 在head中引入Google的html5.js文件

  <!--[if IE]>

  <script src = "............../html5.js"></script>
<![endif]-->

### --- 前端需要注意哪些SEO、语义化

- 语义化：提高网站在搜索引擎的排名、利于爬虫、代码可读性强易维护、利于盲人阅读器
- 优化局部SEO：预渲染

1. 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可
2. 语义化的HTML标签，符合W3C规范：语义化代码让搜索引擎容易理解网页
3. 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
4. 重要内容不要用js输出：爬虫不会执行js获取内容
5. 少用iframe：搜索引擎不会抓取iframe中的内容
6. 非装饰性图片必须加 **alt**
7. 提高网站速度：网站速度是搜索引擎排序的一个重要指标

### --- 移动端模拟 or 真机测试

- 模拟器：  Mac：模拟器 - xcode

			window：模拟器 - Android Studio

			hbuilderx：数据线连手机，基座运行

- 关闭iOS键盘首字母大写：`<input type="text" autocapitalize="off" />`
- 只能输入数字：`<input type="tel" autocapitalize="off" />`

### --- Doctype作用

- doctype必须位于文档最前面，处于文档标签之前，告诉浏览器文档使用哪种html或XHTML。
- 现代浏览器的html布局引擎通过检查doctype决定使用**混杂模式**（不写DTD）还是**标准模式**对文档进行渲染
- - 标准：盒模型的解析（content）、div中唯一图片下有3像素空白
- 在HTML4.01中`<!doctype>`声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容
- HTML5不基于SGML，所以不用指定DTD

### --- XHTML 和 HTML区别

- XHTML 元素必须被正确地嵌套。
- XHTML 元素必须被关闭。
- 标签名必须用小写字母。
- XHTML 文档必须拥有根元素。

### --- href与src的区别

1、请求资源类型不同：href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；

2、作用结果不同：href 用于在当前文档和引用资源之间确立联系；src 用于替换当前内容；

3、浏览器解析方式不同：当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。

### --- HTML全局属性(global attribute)

参考资料：[MDN: html global attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes)或者[W3C HTML global-attributes](http://www.w3.org/TR/html-markup/global-attributes.html#common.attrs.core)

- `accesskey`:设置快捷键，提供快速访问元素如[aaa](https://github.com/attax1994/FE-interview#)在windows下的firefox中按`alt + shift + a`可激活元素
- `id`: 元素id，文档内唯一
- `class`:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素
- `style`: 行内css样式
- `lang`: 元素内容的的语言
- `title`: 元素相关的建议信息
- `dir`: 设置元素文本方向
- `draggable`: 设置元素是否可拖拽
- `contenteditable`: 指定元素内容是否可编辑
- `contextmenu`: 自定义鼠标右键弹出菜单内容
- `data-*`: 为元素增加自定义属性
- `dropzone`: 设置元素拖放类型： copy, move, link
- `hidden`: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果
- `spellcheck`: 是否启动拼写和语法检查
- `tabindex`: 设置元素可以获得焦点，通过tab可以导航
- `translate`: 元素和子孙节点内容是否需要本地化

### --- iframe 的优缺点

比较老了`<iframe src="xx.html" frameborder="0"></iframe>`

**优点：**1、可以重复调用；2、重载页面的时候，不需要加载整个页面；3、维护性好，修改简单

**缺点：**1、兼容性不好，手机端显示不全；2、浏览器后退按钮无效；3、阻塞页面的onload事件；4、因为是多框架页面，会增加http请求

### --- div+css较table的优点

- 更灵活
- 修改更方便，语义化好，利于爬虫、搜索SEO优化

### ---  渐进增强

是指在web设计时强调可访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能同时为高级浏览器和高带宽用户提供更好的用户体验。核心原则如下:

- 所有浏览器都必须能访问基本内容
- 所有浏览器都必须能使用基本功能
- 所有内容都包含在语义化标签中
- 通过外部CSS提供增强的布局
- 通过非侵入式、外部javascript提供增强功能
- end-user web browser preferences are respected

### --- [canvas](D:\文件\前端\笔记\JS_CSS查漏补缺\HTML5canvas.md)

## **CSS相关**

### --- 布局：圣杯、双飞翼、flex布局

- 三列布局，中间宽度自适应，两边定宽；
- 中间栏要在浏览器中优先展示渲染；
- 允许任意列的高度最高；

1、**圣杯布局：** 需要设置position定位

- 设置container包裹 main、left、right，设置container左右外边距，为left、right留出位置
- 设置main、left、right 左浮动，main 宽度为100%，left、right根据需求设置宽度，left、right的 margin-left 设置为 -100%、-宽度
- 设置**main、left、right 的 position 为 relative，left左移它的宽度，right右移它的宽度**
- :warning:因为子元素都为浮动元素，所以此时会出现父容器塌陷，但是此时不应该使用 overflow：hidden，因为左右会被隐藏；这时候就需要使用after伪元素了！！！

2、**双飞翼：** 与圣杯布局的区别在于： “中间栏div内容不被遮挡”问题的思路不一样。 

- 给 main 增加一个子元素 div content，main宽度为100%
- 三个都设置float：left、height、background
- 左右设置宽度，左：左外边距 -100%；右：左外边距 -宽度
- 设置 content 的 左右 margin 分别为 left、right 的宽度

**自己想到的方法：**中间宽度为：**width: calc(100% - 200px)**，此处为计算宽度，因为宽度要跟随左右侧栏宽度实现自适应

**3、flex 弹性布局**：代码量最少！！

- container：main、left、right，设置container的 display 为 flex
- left 的 order 为 -1，强制转换到main左边
-  设置 main 的 flex-grow（放大比例）为1，left、right 默认为 0 
- 设置 left、right 的 flex-basis 占主轴的空间宽度

### ---   flex  及 使用场景

- App 的 百分比布局，使用flex弹性布局来排布
- 微信小程序的布局就使用flex

**容器：**

- flex-direction：row / row-reverse / column / column-reverse （方向）
- flex-wrap：nowrap(默认) / wrap / wrap-reverse （换行）
- flex-flow：[flex-ditection] | [flex-wrap] 
- justify-content：flex-start / flex-end / center / space-between / space-around  （水平对齐方式）
- align-items：flex-start / flex-end / center （垂直方向对齐方式）
- align-content (多根轴线才起作用)：flex-start / flex-end / center / space-between / space-around / strech （垂直方向排列）

**项目：**

- order：0 `<num>` (排列顺序)
- flex-grow：0 （放大比例）占剩余空间的比例，0.5 则未占满的0.5空间
- flex-shrink：1 `<num>`（缩小比例）若沾满全部空间，则缩小对应比例
- flex-basis：auto `<length>` ，定义在分配多余空间之前，项目占主轴的空间
- flex：[flex-grow] | [flex-shrink] | [flex-basis]
- align-self：auto / flex-start / flex-end / center / baseline / stretch 

### --- 水平垂直居中

1. margin：父position: relative; 子position: absolute；left/right/top/bottom = 0; margin: auto;

2. position：大容器为relative；将小容器定位为absolute，top/left：50%，最后将它margin-top，margin-left：-50%；或transform: translate(-50%,-50%)（不知道宽高时）

3. flex：容器display：flex

   justify-content: center主轴上居中

    align-items: center交叉轴上

   老版本：display：-webkit-box-pack: center；-webkit-box-align: center

4. text-align：center 水平居中  子元素必须是inline-block或inline

5. vertical-align：middle 垂直居中，元素为display：table-cell，关于vertical-align详见下方

### --- 栅格布局

父容器：

```css
.container {
            display: grid;
            grid-template-rows: 100px 100px 100px; /*1fr 1fr fr，按宽高自动分配*/
            grid-template-columns: 100px 100px 100px;
     	 grid-template: repeat(3, 1fr) / repeat(3, 1fr); /*简单写法*/
        }
```

### ---  css选择器

**优先级：**!important > style行内选择器 1000 > id 100 > class 10 > tag 1 > 通配符

CSS选择器有哪些

1. ***通用选择器**：选择所有元素，**不参与计算优先级**，兼容性IE6+
2. **#X id选择器**：选择id值为X的元素，兼容性：IE6+
3. **.X 类选择器**： 选择class包含X的元素，兼容性：IE6+
4. **X Y后代选择器**： 选择满足X选择器的后代节点中满足Y选择器的元素，兼容性：IE6+
5. **X 元素选择器**： 选择标所有签为X的元素，兼容性：IE6+
6. **:link，：visited，：focus，：hover，：active**： 选择特定状态的链接元素，顺序LoVe HAte，兼容性: IE4+
7. **X + Y直接兄弟选择器**：在**X之后第一个兄弟节点**中选择满足Y选择器的元素，兼容性： IE7+
8. **X > Y子选择器**： 选择X的子元素中满足Y选择器的元素，兼容性： IE7+
9. **X ~ Y兄弟**： 选择**X之后所有兄弟节点**中满足Y选择器的元素，兼容性： IE7+
10. **[attr]**：选择所有设置了attr属性的元素，兼容性IE7+
11. **[attr=value]**：选择属性值刚好为value的元素
12. **[attr~=value]**：选择属性值为空白符分隔，其中一个的值刚好是value的元素
13. **[attr|=value]**：选择属性值刚好为value或者value-开头的元素
14. **[attr^=value]**：选择属性值以value开头的元素
15. **[attr$=value]**：选择属性值以value结尾的元素
16. *[attr=value]**：选择属性值中包含value的元素
17. **[:checked]**：选择单选框，复选框，下拉框中选中状态下的元素，兼容性：IE9+
18. **X:after, X::after**：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），CSS3中::表示伪元素。兼容性:after为IE8+，::after为IE9+
20. **:not(selector)**：选择不符合selector的元素。**不参与计算优先级**，兼容性：IE9+
21. **::first-letter**：伪元素，选择块元素第一行的第一个字母，兼容性IE5.5+
22. **::first-line**：伪元素，选择块元素的第一行，兼容性IE5.5+
23. **:nth-child(an + b)**：伪类，选择前面有an + b - 1个兄弟节点的元素，其中n >= 0， 兼容性IE9+
24. **:nth-last-child(an + b)**：伪类，选择后面有an + b - 1个兄弟节点的元素 其中n >= 0，兼容性IE9+
25. **X:nth-of-type(an+b)**：伪类，X为选择器，**解析得到元素标签**，选择**前面**有an + b - 1个**相同标签**兄弟节点的元素。兼容性IE9+
26. **X:nth-last-of-type(an+b)**：伪类，X为选择器，解析得到元素标签，选择**后面**有an+b-1个相同**标签**兄弟节点的元素。兼容性IE9+
27. **X:first-child**：伪类，选择满足X选择器的元素，且这个元素是其父节点的第一个子元素。兼容性IE7+
28. **X:last-child**：伪类，选择满足X选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性IE9+
29. **X:only-child**：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容性IE9+
30. **X:only-of-type**：伪类，选择X选择的元素，**解析得到元素标签**，如果该元素没有相同类型的兄弟节点时选中它。兼容性IE9+
31. **X:first-of-type**：伪类，选择X选择的元素，**解析得到元素标签**，如果该元素 是此此类型元素的第一个兄弟。选中它。兼容性IE9+

### --- `display: none;`与`visibility: hidden;`的区别

联系：它们都能让元素不可见

1. display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见
2. display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式
3. 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。
4. 读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容

### ---  px、em、rem、vw、vh

- px：像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。

- em：相对于父元素的font-size，默认是为浏览器字体尺寸16px

- rem：相对大小，但相对的只是HTML根元素的font-size。 

  html {font-size: 62.5%;/*10 ÷ 16 × 100% = 62.5%*/}
  body {font-size: 1.4rem;/*1.4 × 10px = 14px */}
  h1 { font-size: 2.4rem;/*2.4 × 10px = 24px*/}

  <html data-dpr:"2" class="iphone6" style="font-size:xxxpx"></html>

  当页面domready后设置document.documentElement.style.fontSize = document.documentElement.clientWidth / 6.4 + 'px';

- %：百分比的参照物是父元素，

- vw：1vw等于视口宽度的1%。

- vmin：选取vw和vh中最小的那个。

### --- @media媒体查询

PC和移动端都能按照不同的设计稿显示出来，那么你需要做的就是去设置媒体查询。

```css
@media only screen and (min-device-width : 320px) and (max-device-width : 480px) {
  /* Styles */
}  /*使用例子*/
```



### --- 盒模型

- 标准盒模型：默认，width就是content的宽度
- box-sizing：border-box时，盒子的width为border+padding+content的总和 

### --- [ meta标签](D:\文件\前端\笔记\JS_CSS查漏补缺\css布局整理position&flex等.md)

提供元信息（名称/值对）

移动端开发时首先设置：

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"> 

- name：名称/值对中的名称。常用的有author、description、keywords、generator、revised、others。 把 content 属性关联到一个名称。
- http-equiv：没有name时，会采用这个属性的值。常用的有content-type、expires、refresh、set-cookie。把content属性关联到http头部。
- content： 名称/值对中的值， 可以是任何有效的字符串。 始终要和 name 属性或 http-equiv 属性一起使用。
- scheme： 用于指定要用来翻译属性值的方案。

### --- css可以继承的属性

- 字体相关：line-height, font-family, font-size, font-style, font-variant, font-weight, font、word-break、[letter-spacing](https://developer.mozilla.org/en-US/docs/Web/CSS/letter-spacing)、text-align]、[text-rendering](https://developer.mozilla.org/en-US/docs/Web/CSS/text-rendering)、[word-spacing](https://developer.mozilla.org/en-US/docs/Web/CSS/word-spacing)、[white-space](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)、[text-indent](https://developer.mozilla.org/en-US/docs/Web/CSS/text-indent)、text-transform、text-shadow
- 文本相关： letter-spacing, text-align, text-indent, text-transform, word-spacing
- 列表相关：list-style-image, list-style-position, list-style-type, list-style
- 颜色：color
- visibility
- cursor

### --- css3新属性

1. 边框：border-radius|box-shadow:10px 10px 5px #xxxxxx|border-image
2. 背景：background-size|background-origin:content-box/padding-box/border-box|允许多个背景图片：background-image：url(),url()|text-shadow|word-wrap：break-word允许文本换行
3. 字体：@font-face自定义字体
4. 伪类
    - :empty  没有子元素的element元素
    - :enable  选择每个已启动的元素
    - :disable  选择每个已禁止的元素
    - :chacked  选择每个被选中的元素
    - :target  选择当前活动的元素

5. 2D、3D转换transform
6. 过渡效果：transition
7. 动画animation，结合@keyframes使用

### --- box-shadow

box-shadow: 10px 10px 5px 5px #xxx insert

- h-shadow: 水平阴影位置
- v-shadow：垂直阴影位置，与水平位置一样可为负，必选
- blur：模糊距离
- spread：阴影尺寸
- color：阴影颜色
- insert：内部阴影

### --- css3 渐变：线性/径向渐变

- 线性渐变（(repeat-)linear-gradient）- 向下/向上/向左/向右/对角方向

  background: linear-gradient(*direction*, *color-stop1*, *color-stop2, ...*);

  direction: to bottom right / xdeg 

  color: color  x% ：颜色中心所在的位置

- 径向渐变（(repeat-)radial-gradient）- 由它们的中心定义

### --- 动画 transform、transition、animation、

- 2D转换transform：translat(x,y)|rotate(30deg)|scale(x,y)缩放|skew(30deg,20deg)水平垂直翻转角度|matrix()2D方法组合
- - 3D转换：rotateX(120deg)|rotateY()|

- 过渡效果：transition-property:color background|transition-duration|transition-timing-function:sase/liner/ease-in/ease-out/ease-in-out/cubic-bezier（num,num,num,num）|transition-deley|

  简写： transition: *property* *duration* *timing-function* *delay*; 

  ​		过渡的属性，完成过度效果需要时间，速度曲线，延迟时间 

  ​		.one1{transition: width 3s linear 2s;}    .one1:hover{width:300px;} 

- animate动画：@keyframes规则：animation-name|animation-duration|animation-timing-function|animation-delay|animation-iteration-count:inifinite/number|animation-direction:normal/alternate动画播放方向|animation-play-state:running/paused元素动画播放状态

  animation的使用必须结合@keyframes animation-name使用 

  *animation: name duration timing-function delay iteration-count direction;* 

  @-webkit-keyframes  move {

  ​                    form{ left:0px;}   *to{ left:200px;}*

  ​             *}*

- **transition&animation区别：**

1. 触发条件不同。**transition通常和hover等事件配合**使用，**由事件触发**。animation则立即播放。

2. 循环。 animation可以设定循环次数。

3. 精确性。 animation可以设定每一帧的样式和时间。tranistion 只能设定头尾。 animation中可以设置每一帧需要单独变化的样式属性， transition中所有样式属性都要一起变化。

4. 与javascript的交互。animation与js的交互不是很紧密。tranistion和js的结合更强大。js设定要变化的样式，transition负责动画效果，天作之合，比之前只能用js时爽太多。

- **贝塞尔曲线：**`cubic-bezier(n,n,n,n)`自定义平滑曲线。贝塞尔曲线有4个点，左下为起始点P0坐标固定为(0,0)，右上为终点P3坐标固定为(1,1)，中间有两点P1和P2的坐标就是`cubic-bezier(n,n,n,n)`的参数。通过4条连起来的直线，生成平滑的曲线。

  `linear`是匀速过渡，`ease`是先快再慢的节奏，`ease-in`是加速冲刺的节奏，`ease-out`是减速到停止的节奏，`ease-in-out`是先加速后减速

### --- link和@import的区别

1. `link`是HTML方式，加载css外还可以定义RSS等其他事务；`@import`是CSS方式，只能加载css
2. `link引用CSS时，在页面载入时同时加载（并行）；@import需要页面网页完全载入以后加载（串行），出现[FOUC](http://www.bluerobot.com/web/css/fouc.asp/)
3. `link`可以通过`rel="alternate stylesheet"`指定候选样式
4. 浏览器对`link`支持早于`@import`，可以使用`@import`对老浏览器隐藏样式
5. `@import`必须在样式规则之前，可以在css文件中引用其他文件
6. 总体来说：**link优于@import**

### ---  什么是FOUC?如何避免

Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。**解决方法**：把样式表放到文档的`head`

### ---`display: block;`和`display: inline;`的区别

`block`元素特点：1.处于常规流中时，如果`width`没有设置，会自动填充满父容器 2.可以应用`margin/padding` 3.在没有设置高度的情况下会扩展高度以包含常规流中的子元素 4.处于常规流中时布局时在前后元素位置之间（独占一个水平空间） 5.忽略`vertical-align`

`inline`元素特点：1.水平方向上根据`direction`依次布局 2.不会在元素前后进行换行 3.受`white-space`控制 4.`margin/padding`在竖直方向上无效，水平方向上有效 5.`width/height`属性对非替换行内元素无效，宽度由元素内容决定 6.非替换行内元素的行框高由`line-height`确定，替换行内元素的行框高由`height`,`margin`,`padding`,`border`决定 6.浮动或绝对定位时会转换为`block`7.`vertical-align`属性生效

### ---  z轴上的默认层叠顺序如下（从下到上）：

1. 根元素的边界和背景
2. 常规流中的元素按照html中顺序
3. 浮动块
4. positioned元素按照html中出现顺序

### --- float浮动

**浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。**

**由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。**

\1. 标准流中的块级盒子，宽度将会自动伸展为100%，而浮动的块级盒子，宽度不会自动伸展，而是由内容冲开（宽度取决于内容的多少）；
2.当一个盒子浮动，标准流中未浮动的其他盒子，将视浮动盒子不存在而占据浮动盒子原来的位置（浮动盒子，会盖在这个盒子上方）。但是，未浮动盒子中的内容，将会受到浮动盒子的宽度的影响（为浮动盒子中的内容，不会被浮动盒子盖住）。
3.由于第二条的原因。我们可以给受浮动影响的盒子，添加clear属性，清除掉浮动盒子对自身的影响。clear可选值：left-清除左浮动影响，right-清除右浮动影响，both-同时清除左右浮动造成的影响.父盒子没有指定高度，如果子盒子没有设置浮动，则父盒子的高度可以被子盒子撑开。
面试题可能遇到：
如果，父盒子中所有的子盒子都设置浮动，那么父盒子的高度将变为0。**父容器塌陷问题**

**解决：**1、父容器设置overflow：hidden；2、父容器::after{display:block;content:"";clear:both;visibility:hidden};3、父容器内部最后添加一个高度为0的div,clear:both

:warning:**补充：文字围绕问题**

带有浮动属性的元素会脱离标准流进行排列布局，脱离标准流后的元素就不和块元素相处在同一个流不居中，使得带有浮动属性的元素漂浮在正常块元素上面。但是 浮动的块虽然脱离了正常的文档流，但是依然占据正常文档流的文本空间。于是在其后面写的文本并不会被浮动元素所覆盖而是继续水平排列超出换行。

标准流中块元素每个各占一行。内联元素则是水平排列，直到一行排列不下进行换行操作。因为使用了float的元素占据文本空间，使得后面的文本以除了浮动元素之外的空间为排列基准，形成了文本环绕的效果。

**PS：**:heavy_exclamation_mark:汉字会默认换行，但一串英文会被识别为一个单词，默认不换行，一列到头

### --- 清除浮动：父容器塌陷问题

由于子元素全部浮动，导致父容器高度为零，造成容器塌陷问题。

- 给父部盒子一个高度，缺点不能自适应高度
- 给父盒子内部最后面添加一个子div，设置clear：both，缺点：多添加了一个元素
- 父盒子设置：overflow：hidden，原因：使元素具有BFC而不会受子元素的影响 
- 父盒子添加一个虚拟子元素： :after {display: block; content: ' '; clear: both;}，这三个元素缺一不可！！！

### --- [深入理解vertial-align属性](https://www.cnblogs.com/starof/p/4512284.html?utm_source=tuicool&utm_medium=referral)

:star:一种实现子元素垂直居中的方法：

```css
::after{
    display: inline-block;
    content:'';
    width: 0;
    height: height;
    vertial-align: middle;
}  /*其他inline-block也设置为：vertial-align: middle;*/
```

:question:两个div 都设置 display：inline-block，正常显示；但是在第二个div中加一个块级元素或者内联元素，显示就变了个样 

![](D:\文件\前端\笔记\imgs\vertical-align.PNG)

:warning:解决方案是给第一个div设置vertial-align: top

**为什么呢？**

``` css 
'vertical-align'
Value:      baseline | sub | super | top | text-top | middle | bottom | text-bottom | <percentage> | <length> | inherit
Initial:      baseline
Applies to:      inline-level and 'table-cell' elements
Inherited:      no
Percentages:      refer to the 'line-height' of the element itself
Media:      visual
Computed value:      for <percentage> and <length> the absolute length, otherwise as specified
```

 **适用于：**

inline水平的元素

- inline:<img>,<span>,<strong>,<em>,未知元素
- inline-block:<input>(IE8+),<button><IE8+>....

'table-cell'元素

- table-cell:<td>

所以默认情况下，图片，按钮，文字和单元格都可以用vertical-align属性。

**baseline的确定规则**

1、inline-table元素的baseline是它的table第一行的baseline。

2、父元素【line box】的baseline是最后一个inline box 的baseline。 

3、inline-block元素的baseline确定规则

- 规则1：inline-block元素，如果内部有line box，则inline-block元素的baseline就是最后一个作为内容存在的元素[inline box]的baseline，而这个元素的baseline的确定就要根据它自身来定了。
- 规则2：inline-block元素，如果其内部没有line box或它的overflow属性不是visible，那么baseline将是这个inline-block元素的底margin边界。

### --- 回流和重绘

**触发重绘的条件：**改变元素外观属性。如：color，background-color等。 

**触发重排的条件：**任何页面布局和几何属性的改变都会触发重排，比如：
　　1. 页面渲染初始化；(无法避免)

　　2. 添加或删除可见的DOM元素；

　　3. 元素位置的改变，或者使用动画；

　　4. 元素尺寸的改变——大小，外边距，边框；

　　5. 浏览器窗口尺寸的变化（resize事件发生时）；

　　6. 填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；

　　7. 读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)在多次使用这些值时应进行缓存。 

**优化：**

1. 浏览器自己的优化：浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。 
2. 减少对渲染树的操作，则我们可以**合并多次的DOM和样式的修改**。并减少对style样式的请求。 
   - 直接改变元素的className 
   - display：none；先设置元素为display：none；然后进行页面布局等操作；设置完成后将元素设置为display：block；这样的话就只引发两次重绘和重排； 
   - 不要经常访问浏览器的flush队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流； 
   - 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； 
   - 将需要多次重排的元素，position属性设为absolute或fixed，元素脱离了文档流，它的变化不会影响到其他元素； 
   - 如果需要创建多个DOM节点，可以使用DocumentFragment创建完后一次性的加入document； 
   - 尽量不要使用table布局。 
   - translate属性值来替换top/left/right/bottom的切换，scale属性值替换width/height，opacity属性替换display/visibility等等 

### ---  calc()函数，用于动态计算长度值。 

任何长度值都可以使用calc()函数进行计算；calc()函数支持 "+", "-", "*", "/" 运算; calc()函数使用标准的数学运算优先级规则 

- 注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)； 



### --- [will-change属性](https://www.cnblogs.com/xiaohuochai/p/6321790.html)

will-change属性可以提前通知浏览器我们要对元素做什么动画，这样浏览器可以提前准备合适的优化设置。这样可以避免对页面响应速度有重要影响的昂贵成本。元素可以更快的被改变，渲染的也更快，这样页面可以快速更新，表现的更加流畅。 

使用will-change提示浏览器关于即将发生的变形十分简单，添加个CSS属性就行

```
will-change: transform;
```

也可以告诉浏览器要改变元素的滚动条位置，或者多个要变化的属性，写下属性的名字就行，也可以写多个，逗号隔开

```
will-change: transform, opacity;
```

对于一般的优化，当变化完成的时候浏览器会撤销优化，恢复普通模式，但是如果使用了will-change会导致该优化迟迟不能释放，这就要求我们用完了就释放

这时候我们需要借助JavaScript

当然对于用户会反复触发的操作放在style中不移除也可以 

### --- [filter](https://www.cnblogs.com/zheshiyigemanong/p/6943205.html) 

滤镜，官方定义filter属性定义了元素(通常是<img>)的可视效果(例如：模糊与饱和度)；举个栗子：  

```css
filter: none | blur() | brightness() | contrast() | drop-shadow() | grayscale() | hue-rotate() | invert() | opacity() | saturate() | sepia() | url();
```

- 1　　grayscale灰度

  2　　sepia褐色（有种复古的旧照片感觉）

  3　　saturate饱和度

  4　　hue-rotate色相旋转

  5　　invert反色

  6　　opacity透明度

  7　　brightness亮度

  8　　contrast对比度

  9　　blur模糊　　

  0　　drop-shadow阴影

### --- 用css实现三角形

width：0；height：0；border：100px solid；border-top-color: red；border-right-color: transparent；border-bottom-color: transparent；。。。

## **JavaScript相关**

### -   数值类型 — 基本、引用

null、undefined、boolean、number、string、symbol、object（array、function）

- undefined：声明了，但未被赋值
- null：曾经被赋值，现在没有值
- NaN：计算失败得到的结果 NaN ！= NaN

基本数据类型：null、undefined、boolean、number、string、symbol

引用类型：object、array、function、data、正则、math

栈(stack)和堆（heap）：stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小也不一定会自动释放

**区别：**

1. 声明变量时内存分配不同

- 原始类型：存在栈中，占据固定空间
- 引用类型：存在堆中，栈中存储的变量是引用地址。因为栈分配内存后就不会改变大小，而引用值的大小会改变，所以存储值不变的地址。

2. 访问机制不同

- 引用类型按引用地址访问。
- 基本类型的值直接访问。

3. 复制变量时的不同

- 基本类型：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，**此后这两个变量是完全独立的，他们只是拥有相同的value而已。**
- 引用值：在将一个保存着对象内存地址的<u>变量赋给给另一个变量时</u>，会把这个内存地址赋值给新变量，指向堆中同一个对象，任何一个作出的改变都会反映在另一个身上

**基本包装类型和引用类型主要区别：**对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都是一直保存在内存中.而自动创建的**基本包装类型的对象，则只存在于一行代码的执行瞬间**，然后立即被销毁（说的详细一点就是，JS引擎通过在内部临时创建一个对应的包装类型的临时对象，并把对基本类型的操作代理到这个临时对象身上，使得对基本类型的属性访问看起来像对象一样。但是在操作完成后，临时对象就扔掉了，下次再访问时，会重新建立临时对象，当然对之前的临时对象的修改都不会有效。）。所以基本类型的值是不可以被方法改变的，调用方法后返回的是新的值，原来的变量值没有变。

### -   为什么string、number也有自己的方法

JavaScript 为基本数据类型值提供了封装对象，称为原生函数（如 String、Number、Boolean 等）。它们为基本数据类型值提供了该子类型所特有的方法和属性（如：String#trim() 和 Array#concat(..)）。

对于简单标量基本类型值，比如 "abc"，如果要访问它的 length 属性或 String.prototype 方法，JavaScript 引擎会自动对该值进行封装（即用相应类型的封装对象来包装它）来实 现对这些属性和方法的访问。

当原始数据类型（boolean，Number、String）在调用方法时，JS 将会创建对象，以便调用方法属性，而在使用完毕后将会销毁该对象。原始值被当作构造函数创建的一个对象来使用时， JS 会将其转换为一个对象，以便其可以使用对象的特性（如方法），而后抛弃对象性质，并将它变回到原始值。

### -   instanceof、typeof、Object.stringOf

```javascript
typeof: undefined、boolean、number、string、symbol、object、function
console.log(typeof NaN); // number
console.log(typeof undefined);  // undefined
console.log(typeof null); // Object
console.log(typeof []); // Object
```

⭐️**instanceof：左边是对象，右边是函数**	就是检查，左边对象的原型链上 是否存在 右边构造函数的原型

​    反过来操作就是：Foo.prototype.isPrototypeOf(a)：foo是否出现在a的原型链中

​	使用instanceof容易造成误解：

⚠️需要注意的是，构造函数本身还是函数，new操作符只是将其调用方式变成“构造函数调用”，本质上还是需要去执行它。在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。

### -  数组复制方法

- var arr2 = Object.assign([], arr); 或 var arr2 = []; Object.assgin(arr2, arr)；
- var arr2 = arr.map(item => item);
- 扩展运算符：var arr2 = [...arr];
- 从原数组中截取，组成新数组：var arr4 = arr.slice(0);
- concat[] 接上一个空数组，返回新数组: var arr4 = arr.concat([]); 
- for 循环遍历一个个赋值

### -  数组去重

- indexOf方法：新建一个数组，遍历去要重的数组，当值不在新数组的时候（indexOf为-1）就加入该新数组中；

- 排序后去除相邻：给传入的数组排序，排序后相同的值会相邻，然后遍历排序后数组时，新数组只加入不与前一值重复的值。

- ES6 set数据结构：它类似于数组，但是成员的值都是唯一的，没有重复的值。Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。  

  ```JavaScript
  function unique5(arr){
    var x = new Set(arr);
   return [...x];
  }
  ```

### - 深拷贝 浅拷贝

基本数据类型：undefined、null、boolean、number、string，直接存在栈（stack）中，单独存在，互相之间没有联系。

引用类型：复杂数据类型Object，存储的是该对象在栈中引用，真实的数据存在堆内存中。引用类型的赋值只是给了堆内存对象中的引用指针，当一个改变后，另一个也会改变

浅拷贝：浅拷贝只复制对象的第一层属性，第二层甚至更多层只拷贝其引用

深拷贝：把一个对象中所有属性和方法一个个找到，并且在另一个对象中开辟相应空间，一个个存储到另一个对象中

- 不完美深拷贝1：Object.assign(target, source)：用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。 当我们不涉及到第二层或者更深层的包含复杂数据类型，可见`Object.assign()`方法是基本可行的，但是如果对象中包含另一层`Object`或者`Array`这样的引用类型，他们还是保存的指针，而不是真的复制出一个新的`Object`或者`Array` 

- 不完美深拷贝2：`JSON.stringify()`和`JSON.parse()`**他无法实现对函数 、RegExp等特殊对象的克隆** 2. **会抛弃对象的constructor,所有的构造函数会指向Object** 3. **对象有循环引用,会报错** 

- 手动实现（不成熟）：

  ```javascript
  function extend(source,targrt){
      for(var key in source){
          var item = source[key]
          if(item instanceof Array){
              targrt[key] = []
              extend(item,targrt[key])
          }else if(item instanceof Object){
              b[key] = {}
              extend(item,b[key])
          }else{
              b[key] = item
          }
      }
  }
  ```

- 最佳深拷贝：Lodash的`_.cloneDeep`，Lodash是一个一致性、模块化、高性能的JavaScript实用工具库 ，判断的项目测20来项，不仅有数据类型的判断，还有浮点数的判断，多少位的浮点数的判断，反正就是很多判断，以及边界考虑。 

- ```javascript
  var deep = _.cloneDeep(objects);
  ```

### -   严格模式

- 变量必须声明后再赋值
- 不能有重复的参数名，函数的参数也不能有同名属性
- 不能使用with语句
- 不能对只读属性赋值
- 不能使用前缀0表示八进制数
- 不能删除不可删除的属性
- eval不会在它的外层作用域引入变量。
- eval和arguments不能被重新赋值
- arguments不会自动反应函数的变化
- 不能使用arguments.callee
- 不能使用arguments.caller
- 禁止this指向全局对象
- 不能使用 fn.caller和fn.arguments获取函数调用的堆栈
- 增加了保留字

### -   Object.create(o)

比如`var bar = Object.create(foo);`，使得`bar.__proto__===foo`，从而bar可以通过原型链获得foo的所有属性和方法。当bar.name时，在bar中创建一个键值对，不影响foo中的name

### -   原型

```
【构造函数】 首字母大写，他里面定义了各种需要共享的属性和方法。构造函数里面有prototype属性，是个指针，指向他的【原型对象】，原型对象中有个construction属性，默认指回构造函数。可以向原型对象中写入属性和方法
当new一个【实例对象】时，构造函数中的this指向这个实例对象，实例对象中有个[[Prototype]]，指向构造函数的原型对象，可以通过浏览器提供的`__proto__`来访问到。
```

**继承：**根据`__proto__`一级一级的向上查找，找到了父辈和爷爷辈的属性 

- **构造函数**通过   构造函数.prototype  ，来定义**原型对象**（向其中写入属性和方法），达到共享数据、节省内存的目的
- **原型对象**中有  constructor 构造器，指向他的**构造函数**
- 通过 new 构造函数，可以创建一个**实例对象**，这个实例对象继承了构造函数中的所有属性和方法，同时，可以通过浏览器属性`__proto__ `，来访问原型对象中的属性和方法
- 当输出实例对象中的属性或方法时，会首先输出对应的构造函数中的对应属性或方法，如果找不到，则通过`__proto__ `也就是**原型链**，向上寻找其构造函数中对应的属性或方法，一级一级逐层向上，直到找到为止。
- 一切的原型链都会最终指向 Object.prototype ，而 Object.prototype 的`__proto__`为null。

**new 一个对象的过程:** var obj = new Foo（）

1. 创建了一个新的空对象 {}
2. 将构造函数的作用域赋给新对象（this就指向新对象）执行构造函数的代码（为对象添加属性）
3. 设置原型链，将obj的`__proto__`指向了 Foo 函数对象的 prototype 原型对象
4. 返回新对象 obj

**工厂模式：**函数名小写，函数内部new Object（），有返回对象return X，直接调用函数可以创建

**属性遮蔽：**实例会现在自身查找有没有对应的属性或者方法，如果没有，就去`__proto__`上面去找，如果还没有，就继续在`__proto__.__proto__`去找，一直到为null，停止搜索。这种情况称为"属性遮蔽 (property shadowing)。 

**弊端：**如果在当前实例没有的属性和方法，js就会遍历原型链上所有的属性和方法，这样很耗费性能。所以请注意代码中原型链的长度，并在必要时将其分解，以避免可能的性能问题 

**不要试图修改或扩展原生对象的原型：**尽量不要去修改类似Object.prototype，你可能会覆盖原型属性或方法，也可能对继承自Object的实例发生不可预知的bug**

### - this 指向问题

function foo（）{}

var obj = {}

- 默认绑定：function中的this，如果直接执行，那么指向的是全局对象-window
- 隐式绑定：整个调用链上，处于方法**上一层的对象**，如 obj.foo()，this指的是obj对象
- 显示绑定：call和apply <u>bind的参数形式类似于call，但是返回的是显式绑定后的函数对象，需要后续去调用执行</u>。 **bind常用于柯里化一个函数对象。** 如：foo.call(obj)，this指向obj。（显式绑定中，如果对this不敏感，可以传入`null`，但是可能有副作用。 **更安全的做法是，传入一个空对象**，即`var empty = Object.create(null)`，它连指向Object.prototype的__proto__都没有，比{}更空。）
- new绑定：var obj = new foo（），this指向obj这个实例对象
- ⚠️箭头函数没有this绑定，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）

**优先级**

- new在调用构造函数的时候做初始绑定。
- 显式绑定或硬绑定优先级最高。
- 没有显式绑定，就使用隐式绑定。
- 如果都没有，就使用默认绑定（undefined，是不是全局看严格模式）。

### - call apply bind

- `call()`方法可以指定一个`this`的值（第一个参数），并且分别传入参数（第一个参数后面的就是需要传入函数的参数，需要一个一个传） 

- 可以将this绑定到call定义的对象中，也可以绑定一个空

- apply() 传入参数数组（参数需要在一个数组或者类数组中） 

- 如果我们是在一个函数当中使用，那我们还可以直接使用`arguments`这个类数组对象 

  ```JavaScript 
   function mySayYourWeapon(num, num2) {
      sayYourWeapon.apply(zoro, arguments) 
    }
  ```

- **bind()方法不会立即执行目标函数，而是返回一个原函数的拷贝，并且拥有指定this值和初始函数（为什么是指定的，当然是我们自己传进去的啦）** 

- ❗️**手写bind方法**

  ```javascript
  if (!Function.prototype.bind) {
    Function.prototype.bind = function(oThis) {
      if (typeof this !== 'function') {
        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
      }
      var aArgs = Array.prototype.slice.call(arguments, 1);
      var fToBind = this;
      var fNOP = function() {};
      var fBound  = function() {
          return fToBind.apply(this instanceof fBound ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
      };
      if (this.prototype) {
        fNOP.prototype = this.prototype;
      }
      fBound.prototype = new fNOP();
      return fBound;
    };
  }
  ```

### -   ==   ===  的判断流程

-  ===
   1. 如果两个值不是相同类型，它们不相等 
   2. 如果两个值都是null或者都是undefined，它们相等
   3. 如果两个值都是布尔类型true或者都是false，它们相等
   4. 如果其中有一个是**NaN**，它们不相等  **NaN !== NaN**
   5. 如果都是数值型并且数值相等，他们相等， -0等于0  **-0 === +0**
   6. 如果他们都是字符串并且在相同位置包含相同的16位值，他它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同==和===都认为他们不相等
   7. 如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等

==：比较两个<u>不同类型</u>的值时会发生隐式强制类型转换，会将其中之 一或两者都转换为相同的类型后再进行比较。

- 如果两个值类型相同，按照===比较方法进行比较
- 如果类型不同，使用如下规则进行比较
- 如果其中一个值是null，另一个是undefined，它们相等  **null == undefined**
- 如果一个值是**数字**另一个是**字符串**，将**字符串转换为数字**进行比较
- 如果有布尔类型，将**true转换为1，false转换为0**，然后用==规则继续比较
- 如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较
- **其他所有情况都认为不相等**

!= 就是 == 的相反值，!== 同理

### - 闭包的理解

**什么是闭包**

- 就是在一个外部函数内部创建另一个函数
- 全局调用内部函数的时候可以访问到外部函数的局部变量，并使用！

[**闭包的使用场景：**](https://blog.csdn.net/qq_21132509/article/details/80694517)

- setTimeout 
- 回调 
- 封装变量 
- 事件处理程序
- 模块模式

**优缺点：**

- 逻辑连续，当闭包作为另一个函数调用参数时，避免脱离当前逻辑而单独编写额外逻辑
- 方便调用上下文的局部变量。
- 加强封装性，是第2点的延伸，可以达到对变量的保护作用。
- 延长作用域链：局部变量存在函数中，函数使用完后，局部变量会自动释放，闭包后，局部变量还存在被调用的可能，没有被及时释放，作用域链延长。

闭包会使得函数中的变量都被保存在内存中，内存消耗很大，在IE中可能导致内存泄露。 （动态存储分配函数内存空间，在使用完毕后未释放，导致一直占用该内存单元，直到程序结束）

### -  垃圾清除

1. 标记清除（常用）：垃圾回收机制在运行时会给存储在内存中的所有变量加上标记（可以使用任何标记方式）。然后去掉环境中的变量和被环境变中的变量引用的变量的标记。而在此之后被加上标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾收集器完成内存清除工作，销毁带标记的值并回收他们所占用的内存空间
2. 引用计数：reference counting 含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数为1.如果同一个值又被赋给另一个变量，引用次数加1.相反的，变量包含这个值得引用变量又取得另一个值，则这个值的引用次数减1.当引用次数为0时，将其占用内存回收。（循环引用的变量和函数无法回收）
3. 解决：将完成的函数或变量重置为null。

### -  Ajax  —  XMLHttpRequest()  对象

**优点：**无需重新加载整个网页的情况下，实现部分网页更新的技术。提高用户体验，Ajax技术的核心是XMLHttpRequest对象（简称XHR）；像ajax这种耗时长的操作应该异步执行，避免浏览器失去响应。

**缺点：**1、不支持浏览器back按钮；2、安全问题，暴露与服务器的交互细节；3、对搜索引擎的支持较弱；4、不容易调试；5、破坏了程序异常机制

**ajax流程：**

1. 创建XMLHttpRequest对象  var xhr = new XMLHttpRequest();

2. 创建新的http请求，指定请求方法、url、验证信息等。xhr.open('get', 'url', true/false[是否异步])  [true表示会在send后继续执行，而不等待服务器的响应]

   - 若是post请求，需要设置请求头格式的内容：xhr.setRequestHeader('content-type', 'application/x-www-form-urlenCoded');  [表单提交的格式]

3. 设置响应http请求状态变化的函数。

   ```JavaScript
   xhr.onreadyStatechange = function () {
       if(xhr.readyState == 4 && xhr.status == 200) {
           // 处理：xhr.responseText / responseXML
       } 
   } 
   ```

4. 发送http请求 ：xhr.send()，[若是POST请求，需要写传入的string] — "methodName = GetAllComment&str1=str1&str2=str2"

5. 获取返回的数据并做后续处理，一般接收异步返回的数据，axios等操作

6. 异常捕获：axios catch  ，原生：try {    xhr.send();} catch (e) {    console.log(e);}

**readyState：**0：请求初始化；1：服务器连接已确立；2：请求已接收；3：请求处理中；4：请求完成，响应就绪

**abort()`:**取消异步HTTP请求

getAllResponseHeaders()`: 返回一个字符串，包含响应中服务器发送的全部HTTP报头。每个报头都是一个用冒号分隔开的名/值对，并且使用一个回车/换行来分隔报头行

getResponseHeader(headerName)`:返回headName对应的报头值

### - 原生Ajax请求过程

**手撕过程**

```JavaScript
function getXHR(){
  var xhr = null;
  if(window.XMLHttpRequest) {// 兼容 IE7+, Firefox, Chrome, Opera, Safari
    xhr = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    try {
      xhr = new ActiveXObject("Msxml2.XMLHTTP");// 即MSXML3
    } catch (e) {
      try {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");// // 兼容 IE6, IE5，很老的api,虽然浏览器支持,功能可能不完善,故不建议使用
      } catch (e) {
        alert("您的浏览器暂不支持Ajax!");
      }
    }
  }
  return xhr;
}

var xhr = getXHR();
xhr.open('GET', url/file,true);  //设置请求方式，url，以及是否异步
xhr.onreadystatechange = function() {   //设置回调监听函数
   if(xhr.readyState==4){
        if(xhr.status==200){
            var data=xhr.responseText;
             console.log(data);
   }
};
xhr.onerror = function() {
  console.log("Oh, error");
};
xhr.send();  //发送请求
```

**封装为插件**

**GET**

```JavaScript
function getJSON (url) {
    return new Promise( (resolve, reject) => {
        var xhr = new XMLHttpRequest()
        xhr.open('GET', url, true)

        xhr.onreadystatechange = function () {
            if (this.readyState === 4) {
                if (this.status === 200) {
                    resolve(this.responseText, this)
                } else {
                    var resJson = { code: this.status, response: this.response }
                    reject(resJson, this)
                }
            }
        }
        xhr.send()
    })
}
```

**post**

```JavaScript
function postJSON(url, data) {
    return new Promise( (resolve, reject) => {
        var xhr = new XMLHttpRequest()
        xhr.open("POST", url, true)
        xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

        xhr.onreadystatechange = function () {
            if (this.readyState === 4) {
                if (this.status === 200) {
                    resolve(JSON.parse(this.responseText), this)
                } else {
                    var resJson = { code: this.status, response: this.response }
                    reject(resJson, this)
                }
            }
        }
        xhr.send(JSON.stringify(data))
    })
}
```

**使用**

```JavaScript
getJSON('/api/v1/xxx')    // => 这里面是就try
.catch( error => {
  // dosomething          // => 这里就是catch到了error，如果处理error以及返还合适的值
})
.then( value => {
  // dosomething          // 这里就是final
})
```

### - Ajax轮询、长轮询、websocket

1、`ajax轮询`

让浏览器每隔一定的时间就发送一次请求，询问服务器是否有新信息。

2、`长轮询（Long Poll）`

采用的阻塞模式。客户端发起连接后，如果没消息，服务器不会马上告诉你没消息，而是将这个请求挂起（pending），直到有消息才返回。返回完成或者客户端主动断开后，客户端再次建立连接，周而复始。Comet就是采用的长轮询。

3、`websocket`

WebSocket 是类似 Socket 的TCP长连接通讯模式。一旦 WebSocket 连接建立后，后续数据都以帧序列的形式传输。而且浏览器和服务器就可以随时主动发送消息给对方，是全双工通信。

优点：在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。

### -[ cookie、sessionStorage、localStorage](D:\文件\前端\笔记\JS_CSS查漏补缺\cookie&session.md)

![](D:\文件\前端\笔记\imgs\数据存储.jpg)

- 都会在浏览器端保存，有大小限制，同源限制

- cookie：4-5kb，如果没有设置有效期则关闭浏览器就清除；适用于验证登录状态；有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie；cookie设置secure时要求HTTPS传输

  document.cookie="username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/";

- sessionStorage：4-5M；标签页关闭就清除；数据存储；针对一个session的数据存储

  ```JavaScript
  this.queryParams={name:this.insuredOneName,id:this.insuredOneID};
  sessionStorage.setItem('queryParam',JSON.stringify(this.queryParams))
  ```

- localStorage：4-5M；永久保存，除非手动清除；数据存储；存储js文件，第一次访问页面时加载，以后访问时直接加载本地localStorage

- ```JavaScript
  localStorage.setItem("key", "value");
  var lastname = localStorage.getItem("key");
  localStorage.removeItem("key");
  ```

[cookie和session的区别](https://www.cnblogs.com/andy-zhou/p/5360107.html)

[关系](https://baijiahao.baidu.com/s?id=1625864647248256835&wfr=spider&for=pc)登录访问下次继续访问时

**Unicode编码：保存中文**

中文与英文字符不同，中文属于Unicode字符，在内存中占4个字符，而英文属于ASCII字符，内存中只占2个字节。Cookie中使用Unicode字符时需要对Unicode字符进行编码，否则会乱码。

**Cookie的安全属性**

HTTP协议不仅是无状态的，而且是不安全的。使用HTTP协议的数据不经过任何加密就直接在网络上传播，有被截获的可能。使用HTTP协议传输很机密的内容是一种隐患。如果不希望Cookie在HTTP等非安全协议中传输，可以设置Cookie的secure属性为true。浏览器只会在HTTPS和SSL等安全协议中传输此类Cookie。下面的代码设置secure属性为true：

```JavaScript 
Cookie cookie = new Cookie("time", "20080808"); // 新建Cookie
cookie.setSecure(true); // 设置安全属性
response.addCookie(cookie); // 输出到客户端
```

W3C标准的浏览器会阻止JavaScript读写任何不属于自己网站的Cookie。换句话说，A网站的JavaScript程序读写B网站的Cookie不会有任何结果。 

### -[ 跨域 jsonp、Proxy、CORS](D:\文件\前端\笔记\计算机网络基础\http相关&HTTPS.md)

**同源策略：**不同源的是不能进行请求等操作的，只要满足 **协议、主机、端口** 一致，则两个页面具有相同的源

**跨域：**跨域是不可能靠前端单方面解决，总是需要服务器的支持

**跨域情况：**1、同一父域的子域之间；2、不同父域之间；3、端口不同；4、协议不同

- 3、4需要通过Proxy：发起方的域下创建Proxy程序，发起方的域下调用Proxy，Proxy将请求发送给接收方并获取相应数据，Proxy将获得数据返回给发起的js
- 1、2：document.domain+iframe（只能解决1）：在发起和接收方设置document.domain，并设置为父域的主域名（window.location.hostname）；发起方页面创建隐藏的iframe，iframe的源是接收方页面；根据浏览器的不同，通过iframe.contentDocument || iframe.contentWindow.document来获得接收方页面的内容；通过接收方页面的内容与接收方进行交互。（缺点：当一个域被攻击，另一个域有安全漏洞出现）

**jsonp**

- HTML标签中src和href属性可以请求外部地址，没有跨域限制，根据src这一特性，得到jsonp的跨域请求方式
- 通过动态添加`<script>`的标签，可控的去请求远端js并执行
- 创建一个回调函数，然后在远程服务上调用这个函数并且将JSON 数据形式作为参数传递，完成回调。
- jsonp缺点：只支持get方式，脚本注入行为存在安全隐患。

（1）原生实现：

```JavaScript
var script = document.createElement('script'); // 创建script标签
script.type = 'text/javascript';  // 设置type
// 传参并指定回调执行函数为onBack
script.src = 'http://www.domain2.com:8080/login?user=admin&callback=onBack'; // 设置src，要访问的地址。提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
document.head.appendChild(script); // 将标签插入文档头部
// 回调函数
function onBack(res) {  // 设置回调函数，获取返回的数据，并处理
    alert(JSON.stringify(res));
}
//服务端返回如下（返回时即执行全局函数）：
onBack({"status": true, "user": "admin"}) 
```

（2）jquery ajax：

```JavaScript 
$.ajax({
    url: 'http://www.domain2.com:8080/login',
    type: 'get',
    dataType: 'jsonp',  // 请求方式为jsonp
    jsonpCallback: "onBack",    // 自定义回调函数名
    data: {}
});
```

**Proxy解决跨域问题：**

- 开发 webpack proxy-middleware代理

- proxy 的工作机制是：你依然请求**本地地址**，即使你 `npm run dev` 跑起来的东西并没有任何接口能力，而 Webpack 后台会将所有指定的请求转发到 `target` 对应的地址上。这个转发的过程发生在服务端（也就是 webpack-dev-server），所以你的浏览器是不知道的。 

  ```JavaScript 
  proxy: {
       '/api': {
         target: 'https://list.jd.com/list.html?cat=1318,1462,1480&callback=jQuery942326&md=9&l=jdlist&go=0',
         pathRewrite: {'^/api' : ''},
         changeOrigin:true, //必须要加，否则是访问自己
       	}
    }
  ```

- 生产 nginx代理

  ```JavaScript 
  * 生产环境 配置nginx.conf
  
  * ```js
     location /api {
                # 这里也可以录用原有参数，进行复用，并重写URL
                proxy_pass https://list.jd.com/list.html?cat=1318,1462,1480&callback=jQuery942326&md=9&l=jdlist&go=0;
            }
  ```


**cors：**需要与服务端配合

- “跨域资源共享”，允许浏览器向跨源服务器，发出`XMLHttpRequest`请求，从而克服了AJAX只能同源使用的限制。

- 同源策略不仅在浏览器有限制，在服务端也有限制

- **简单请求**：方法为HEAD、GET或者POST中的一种；HTTP的头信息不超过以下几种字段`Accept`、`Accept-Language`、`Content-Language`、`Last-Event-ID`以及`Content-Type`的值只限于`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`三个

  简单请求时，浏览器会自动在请求头中添加一个字段`Origin`，值为发出请求网页的源地址。服务端根据这个值，决定是否同意这次请求，如果`Origin`的值不在指定的许可范围，服务端返回一个正常的HTTP回应。浏览器未找到Access-Control-Allow-Origin字段，则抛出错误，但这个错误无法通过状态吗识别

- **非简单请求：**`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。浏览器会在正式请求之前发送一次预检请求，option`请求。正式请求之前，浏览器会去问服务端我这个地址能不能访问你，如果可以，浏览器才会发送正式的请求，否则报错。

- 总的来说，CORS实现跨域的方法就是根据请求头的`Origin`值和响应头的`Access-Control-Request-Headers`和`Access-Control-Request-Method`的值进行比对，通过了就可以请求成功，没通过就请求失败。

> JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。

反向代理：**node，Nginx

**同源策略只是浏览器的一个安全策略**，只适用于浏览器向服务器发送请求的时候，当服务器跟服务器发送请求的时候，自然就没有这么一层限制，只要是接口，就会返回。

权限不通过的时候，也是会请求成功200的，只是返回的是“需要登录”等信息

- 正向代理：客户端知道谁是真正返回数据的服务器
- 反向代理：客户端不知道谁是返回数据的服务器

### -:question: void运算符  a-href

```javascript
<a href="javascript:void(0);"></a>
```

这么写是为了让`a`标签没有作用，不会跳转页面，也不会跳转锚点 

**void运算符**对给定的表达式进行求值，然后返回`undefined`;《MDN web docs》 

在使用立即执行的函数表达式时，可以利用`void`运算符让JavaScript引擎把一个`function`关键字识别成函数表达式而不是函数声明（语句）。 

`href="#"`执行的时候会默认执行`href="#top"`，页面的滚动条会滚动到页面的最上面，而且地址栏的地址后面会跟上一个#

**浏览器环境中的局部作用域中是可以更改undefined的值，而在node环境全局和局部都可以更改undefined的值，究其原因，因为undefined在JavaScript中既不是关键字也不是保留字，所以很容易被污染**



### - 点击穿透事件

1. **vue穿透事件：** 解决办法我们只需要v-on:click.stop = '' 就可以阻止事件的穿透到下一级。
2. **jquery穿透事件：** 解决办法我们则需要给穿透层加一个属性  display:block；
3. **事件冒泡：** 阻止事件冒泡， event.preventdefault;   event.stopPropagation(); return:false;

### - 函数内部arguments

- arguments所有函数中都包含的一个局部变量，是一个类数组对象，对应函数调用时的实参。如果函数定义同名参数会在调用时覆盖默认对象
- arguments[index]分别对应函数调用时的实参，并且通过arguments修改实参时会同时修改实参
- arguments.length为实参的个数（Function.length表示形参长度）
- arguments.callee为当前正在执行的函数本身，使用这个属性进行递归调用时需注意this的变化
- arguments.caller为调用当前函数的函数（已被遗弃）
- 转换为数组：`var args = Array.prototype.slice.call(arguments, 0);`

### -  函数防抖、节流

**函数节流：**一个函数执行一次后，只有大于设定的执行周期之后才会执行第二次（比如频繁触发某个函数，出于优化，在规定时间内只有一次生效）

```javascript
function throttle(fn, delay) {
    var lastTime = 0;
    return function () {
        var nowTime = Date.now();
        if(nowTime - lastTime > delay) {
           fn.call(this);  // 修正this指向问题
            lastTime = nowTime;  // 闭包，lastTime会取上一次返回值，而不是0
           }
    }
}
```

**函数节流：**规定时间内，只让最后一次生效，前面的不生效，如频繁点击某个按钮

```JavaScript
function debounce(fn, delay) {
    var timer = null;
    return function () {
        clearTimeout(timer); // 清除延时器
        timer = setTimeOut(function() {  // 重设延时器 
            fn.apply(this);
        }, delay);
    }
}
```



## **DOM相关**

### -  getElementById()、querySelector()

"querySelector 属于 W3C 中的 Selectors API 规范 。而 getElementsBy 系列则属于 W3C 的 DOM 规范" 

1. **区别：**getXXXByXXX 获取的是动态集合，querySelector获取的是静态集合。

   简单的说就是，动态就是选出的元素会随文档改变，静态的不会，取出来之后就和文档的改变无关了。

2. **性能：**getXXXByXXX，获取的若是动态nodelist，那么每一次调用都会重新对文档进行查询，导致无限循环的问题

3. **选择：**如果只要一次查找就可得到元素时，首选getXXXByXXX ；

   如果需要经过多级查找，才能得到元素时，首选querySelector

### -  DOM事件模型

- DOM事件包含捕获（capture）和冒泡（bubble）两个阶段：捕获阶段事件从window开始触发事件然后通过祖先节点一次传递到触发事件的DOM元素上；冒泡阶段事件从初始元素依次向祖先节点传递直到window
- 标准事件监听elem.addEventListener(type, handler, capture)/elem.removeEventListener(type, handler, capture)：handler接收保存事件信息的event对象作为参数，event.target为触发事件的对象，handler调用上下文this为绑定监听器的对象，event.preventDefault()取消事件默认行为，event.stopPropagation()/event.stopImmediatePropagation()取消事件传递
- 老版本IE事件监听elem.attachEvent('on'+type, handler)/elem.detachEvent('on'+type, handler)：handler不接收event作为参数，事件信息保存在window.event中，触发事件的对象为event.srcElement，handler执行上下文this为window使用闭包中调用handler.call(elem, event)可模仿标准模型，然后返回闭包，保证了监听器的移除。event.returnValue为false时取消事件默认行为，event.cancleBubble为true时取消时间传播
- 通常利用事件冒泡机制，事件委托处理程序提高程序性能。

### - getBoundingClientRect()

用于获取某个元素相对于**视窗**的位置集合。集合中有top, right, bottom, left等属性。 

1. 语法：这个方法没有参数。 

2. 返回值类型：TextRectangle对象，每个矩形具有四个整数性质（ 上， 右 ， 下，和左 ）表示的坐标的矩形，以像素为单位。 

   - 　rectObject.top：元素上边<u>到视窗上边</u>的距离;

   - 　rectObject.right：元素右边<u>到视窗左边</u>的距离;

   - 　rectObject.bottom：元素下边<u>到视窗上边</u>的距离;

   - 　rectObject.left：元素左边<u>到视窗左边</u>的距离;

   - :warning:

   - ```
     Element.getBoundingClientRect().width =  border-left-width + padding-left + width + padding-right + border-right-width
     
     Element.getBoundingClientRect().height =  border-top-width + padding-top + height + padding-bottom + border-bottom-width
     ```

### - [js中toggle()及toggleClass()](https://www.cnblogs.com/goodtimealways/p/6894988.html)

- 在javascript中toggle()为连续点击事件,当里面含有多个function(){}函数时,每次点击依次执行里面的function的函数,直至最后一个.随后每次点击都重复对这几个函数的轮番调用,toggle的语法如下
- **toggle(fn1,fn2,fn3·····fnN);**
- 但当toggle（），不带参数时,与show()和hide()的作用一样,切换元素的可见状态,如果元素是可见的,则切换为隐藏状态;如果元素是隐藏的则切换为可见状态,此时括号内可添加()毫秒(如1000)等),slow,normal,fast等;

- toggleClass( )与toggle( )差不多,如果里面含有class样式则移除,没有的话则添加;
- 为toggle方法规定第二个参数，此参数规定方法是执行删除操作还是添加操作。
- - （1）.true，执行添加操作。
- - （2）.false，执行删除操作。
- 规定第二个参数之后，toggle方法失去对类的添加和删除切换功能，只执行一种操作。
- - toggle(class,true)等同于add(class)
- - toggle(class,false)等同于remove(class)
- - 特别说明：IE浏览器并不支持第二个参数。

### -[ requestAnimationFrame](https://blog.csdn.net/vhwfr2u02q/article/details/79492303) 

实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，css3 可以使用 transition 和 animation 来实现，html5 中的 canvas 也可以实现。除此之外，html5 还提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是**请求动画帧。** 

1. **屏幕刷新频率：**屏幕每秒出现图像的次数。普通笔记本为60Hz

2. **动画原理：**计算机每16.7ms刷新一次，由于人眼的视觉停留，所以看起来是流畅的移动。

3. **setTimeout：**通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：1、settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；2、settimeout的固定时间间隔不一定与屏幕刷新时间相同，会引起丢帧。

4. **requestAnimationFrame：**优势：由系统决定回调函数的执行时机。60Hz的刷新频率，那么每次刷新的间隔中会执行一次回调函数，不会引起丢帧，不会卡顿

   使用：

   ```JavaScript 
   var progress = 0;
   //回调函数
   function render() {
       progress += 1; //修改图像的位置
       if (progress < 100) {
              //在动画没有结束前，递归渲染
              window.requestAnimationFrame(render);
       }
   }
   //第一帧渲染
   window.requestAnimationFrame(render);
   ```

   优势：

   - CPU节能：使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而requestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。 
   - 函数节流：在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。 

5. **优雅降级：**由于兼容性问题，需要降级对接口进行封装，优先使用高级特性，再根据浏览器不同情况进行回退，直到只能使用settimeout。参考[GitHub](https://github.com/darius/requestAnimationFrame） 



## **ES6**

### -   constructor( )-----super( )的基本含义

constructor( )——构造方法：这是ES6对类的默认方法，通过 new 命令生成对象实例时自动调用该方法。并且，该方法是类中必须有的，如果没有显示定义，则会默认添加空的constructor( )方法。

super( ) ——继承： 在class方法中，继承是使用 extends 关键字来实现的。子类 必须 在 constructor( )调用 super( )方法，否则新建实例时会报错。

 报错的原因是：子类是没有自己的 this 对象的，它只能继承自父类的 this 对象，然后对其进行加工，而super( )就是将父类中的this对象继承给子类的。没有 super，子类就得不到 this 对象。

### - [阮一峰的babel入门](http://www.ruanyifeng.com/blog/2016/01/babel.html)

### -  for of 循环、for-in

`for...of` 语句创建一个循环来迭代可迭代的对象。在 ES6 中引入的 `for...of` 循环，以替代 `for...in` 和 `forEach()` ，并支持新的迭代协议。`for...of` 允许你遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等。 

`for...in` 循环将遍历对象的所有可枚举属性，还从构造函数的原型中查找继承的非枚举属性 

`for...of` 更多用于特定于集合（如数组和对象），但不包括所有对象。 



### - Array.from()

Array.from()方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组。

-  可以接受第二个参数，类似map（），对数组元素进行操作
- 可以直接将字符串转为数组
- 要将一个类数组**对象**转换为一个真正的数组，必须具备以下条件：

　　1、该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。

　　2、该类数组对象的属性名必须为数值型或字符串型的数字

　　ps: 该类数组对象的属性名可以加引号，也可以不加引号

```JavaScript 
let arrayLike = {
    'name': 'tom', 
    'age': '65',
    'sex': '男',
    'friends': ['jane','john','Mary'],
    length: 4
}
```



### -:star:  Promise

**回调地狱：**代码在层级上，越套越深，很混乱，不易维护

回调两个主要缺陷：缺乏顺序性 和可信任性

```JavaScript 
setTimeout(() => {
    console.log(1);
    setTimeout(() => {
        console.log(2);
        setTimeout(() => {
            console.log(3);
        }, 1000)
    }, 1000) 
}, 1000);
```

于是提出Promise，**可以让异步函数变得竟然有序**，可能有人会说`await`和`async`也可以让异步函数同步执行，但是`await`操作符本来就是用于等待一个Promise对象的。 

**基础：**

1. 要先创建一个Promise对象，并将其作为函数值返回
2. Promis构造函数要求传入函数，传入函数会立即执行，传入函数带有两个参数：resolve（成功回调函数）、reject（失败回调函数）
3. promise的三个状态：pending（初始）、fulfilled（操作成功完成）、rejected（操作失败）
4. .then(resovle， reject)，第一个参数是成功回调，第二个参数就是失败回调。 
5. `.then()`的第二个参数传进去的是一个失败回调的函数，但是`Promise`还有一个`.catch()`的方法，也是用来处理失败的 
6. `.then(resovle， reject)`的`reject`按就近原则，只对最近的这个异步函数进行错误处理，但是对以后的或者之前的异步函数不做处理，而`.catch(reject)`会捕获到全局所有链式上异步函数的错误。 

**链式调用：**

- .then()可以一层一层的传一下去，这也是厉害的地方。 
- `.catch()`紧跟在抛出错误的一步函数后面，会抛出错误，然后继续往下执行。
- `.catch()`会捕获全局错误，但是，`.catch()`写在最后，抛出错误以后，函数会直接跳到`.catch()`然后继续往下执行 

**Promise.all()**

使各种不同的请求，都成功后再一起呈现在页面上

 它会在所有成员的promise都完成(fulfilled)后才会完成(fulfilled)。返回的promise会收到一个完成消息，这是一个由所有传入promise的完成消息组成的数组，与指定的顺序一致。任意一个被拒绝(rejected)，它就立刻进入被拒绝(rejected)状态。

```JavaScript 
// Promise.all()需要传入的就是一个数组，每一项就是每一个异步函数
function timeout(delay) {
  return new Promise((resolve, reject) => {
    setTimeout(resolve, delay * 1000)
  })
}
Promise.all([
  timeout(1),
  timeout(3),
  timeout(5),
]).then(() => {
  console.log('都请求完毕了！')
});
```

**Promise.race()**

会监听所有的`Promise`对象，在等待其中的第一个进入完成状态的`Promise`对象。一旦有第一个`Promise`对象进入了完成状态，该方法返回的`Promise`对象便会根据这第一个完成的`Promise`对象的状态而改变 。

应用：1. 设置超时处理

```JavaScript
// 前面定义的timeoutPromise(..)返回一个promise，
 // 这个promise会在指定延时之后拒绝 
// 为foo()设定超时 
Promise.race( [     
    foo(),                  // 启动foo()    
    timeoutPromise( 3000 )  // 给它3秒钟
] )  .then(     
    function(){         
        // foo(..)按时完成！    
    },    
    function(err){       
        // 要么foo()被拒绝，要么只是没能够按时完成，
        // 因此要查看err了解具体原因     
    }  
); 
```

2. finally：前面例子中的 foo() 保留了一些要用的资源，但是出现了超时，导致这个 promise 被忽略，finally就是用来：超时后主动释放这些保留资源，或者取消任何可能产生的副作用。

   Promise 需要一个 finally(..) 回调注册，这个回调在 Promise 决议后总 是会被调用，并且允许你执行任何必要的清理工作

**其他变体：**

- none: 类似于all，但是完成和拒绝的情况互换。所有promise都被拒绝，则进入fulfilled状态。
- any：类似于all，但是会忽略拒绝，只需要至少一个完成即可。
- first：类似于any，但是只选取第一个完成的promise。
- last：类似于first，但是只选取最后一个完成的promise。

### -   async-[await](https://segmentfault.com/a/1190000011526612?utm_source=tag-newest)

- async：一个标志，表示函数是异步的，函数会返回一个Promise对象，可以使用then方法添加回调函数
- await：必须出现在async函数内部。后面可以跟任何的js表达式，用来等待Promise对象的状态被resolved。如果是promise对象，则会造成异步函数暂停执行，直到promise执行完毕再执行后面的语句。
- 实例：有三个请求需要发生，第三个请求是依赖于第二个请求的解构第二个请求依赖于第一个请求的结果。若用 ES5实现会有3层的回调，若用Promise 实现至少需要3个then。一个是代码横向发展，另一个是纵向发展。async-await就很简单清晰。

### -  执行上下文 EC

理解：代码的执行环境

时机：代码正式执行之前会进入到执行环境

工作：

1. 创建变量对象
   - 变量；函数及函数参数；全局window，局部：抽象，但存在
2. 确认this指向
   - 全局：this — window；局部：this — 调用其的对象
3. 创建作用域链
   - 父级作用域链 + 当前变量对象
4. 扩展  ECObj = {scope chain: 父级作用域链 + 当前作用域链}

### -   事件循环event-loop

JavaScript引擎并不是独立运行的，它运行在宿主环境中，也就是web浏览器中；现在也进入了其他环境，如nodejs服务器领域。这些环境都有一个共同“点”（thread，也指线程），都提供了一种机制来处理程序中多个块的执行，且执行每 块时调用 JavaScript 引擎，这种机制被称为**事件循环**。也就是说，JavaScript事件调度总是由包含它的环境进行。

举例，要发送一个ajax请求，获取服务器数据，就在一个回调函数中设置好响应代码，告诉宿主环境，现在要暂停，一旦完成网络请求拿到数据，就执行这个回调函数。浏览器监听网络响应，拿到数据后，就把回调函数加入到时间循环，调度执行。

一旦有事件需要运行，事件循环就会运行，直到队列清空。事件循环的每一轮称为一个 tick。用户交互、IO 和定时器会向事件队列中加入事件。

### -:warning: 线程-进程相关

为什么JS引擎是单线程的？额，这个问题其实应该没有标准答案，譬如，可能仅仅是因为由于多线程的复杂性，譬如多线程操作一般要加锁，因此最初设计时选择了单线程。。。 

**浏览器内核**

- GUI渲染进程
- js引擎线程
- 事件触发线程
- 定时器触发线程
- 异步http请求线程

**同步与异步**

- JS分为同步任务和异步任务
- 同步任务都在主线程上执行，形成一个`执行栈`
- 主线程之外，**事件触发线程**管理着一个`任务队列`，只要异步任务有了运行结果，就在`任务队列`之中放置一个事件。
- 一旦`执行栈`中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取`任务队列`，将可运行的异步任务添加到可执行栈中，开始执行。

**event-loop**

- 主线程运行时会产生执行栈，

栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）

- 而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调
- 如此循环
- 注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件

**setTimeout、setInterval：**由【定时器线程】控制，计时完成后就会将特定的事件推入事件队列中。

**宏任务、微任务**

- macrotask宏任务中的事件都是放在一个事件队列中的，而这个队列由**事件触发线程**维护（主代码块，setTimeout，setInterval等 ）
- microtask微任务中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由**JS引擎线程维护**（Promise，process.nextTick等 ）

**总结下运行机制：**

- 执行一个宏任务（栈中没有就从事件队列中获取）
- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
- 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
- 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

## **框架相关**

## **vue**

### - vue双向数据绑定

**双向数据绑定：**通过Object.defineProperty()，来劫持各个属性的setter和getter，在数据发生变化时，发送消息给订阅者，触发相应监听回调。

一个text属性被改，n个可观察对象触发行为。

- new Vue以后：1、监视data对象的属性；2、获取到template解析其中的元素，获得{{xxx}} v-model = ‘xxx’；3、给input{{}}初始值，触发xxx的get函数，创建可观察对象（记录节点信息 && 更改行为）加入到观察者的数组中；4、如果发生input事件，更改xxx的值，触发set函数；5、set触发就调用观察者对象的函数，让所有的可观察对象更新。

### - jquery & vue 对比  MVVM、MVC

jQuery是使用选择器\$选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的js的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：`$("lable").val();`,它还是依赖DOM元素的值。 

从jquery到vue或者说是到mvvm的转变则是一个思想想的转变，是将原有的直接操作dom的思想转变到操作数据上去 

**MVVM思想：**MVVM是model-view-viewmodel的缩写，【model】代表数据模型；【view】代表组件，将数据进行显示；【viewmodel】是监听模型数据改变和控制视图行为、处理用户交互的，也就是同步view和model的对象。MVVM架构下，view和model之间没有直接联系，通过viewmodel进行交互。Model和View的交互是双向的，viewmodel通过**双向绑定把**view和model连接起来，view和model之间的同步工作是完全自动的，无需认为干涉，因此只需关注业务逻辑，不需要手动操作dom，复杂的数据状态维护有MVVM统一管理。

- 在vue中：Model:指的是js中的数据，如对象，数组等等。View:指的是页面视图viewModel:指的是vue实例化对象

**MVC思想：**Model-View- Controller的缩写，【Controller】指的是页面业务逻辑。MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下。

### -  渐进式框架

渐进式是什么意思？1、如果你已经有一个现成的服务端应用，你可以将vue 作为该应用的一部分嵌入其中，带来更加丰富的交互体验；2、如果你希望将更多业务逻辑放到前端来实现，那么VUE的核心库及其生态系统来满足需求（core+vuex+vue-route）。VUE允许将一个网页分割成可复用的组件，每个组件都包含属于自己的HTML、CSS、JAVASCRIPT以用来渲染网页中相应的地方。3、如果构建一个大型的应用，vue可以快速初始化一个工程（vue init webpack my-project）。我们可以使用VUE的单文件组件，它包含了各自的HTML、JAVASCRIPT以及带作用域的CSS或SCSS。以上这三个例子，是**一步步递进的，也就是说对VUE的使用可大可小，它都会有相应的方式来整合到你的项目中。**所以说它是一个渐进式的框架。

### -  vue组件的通信方式，父子传参

1. 父 --> 子：父组件中用 :xx = "this.xxx"，子组件通过props来接收

2. 子 --> 父：子组件中定义 this.$emit('eventName', data)；父组件中接收：@eventName="callback"

3. 兄弟组件传参，可以使用EventBus：相互通信的兄弟组件之中，都引入一个新的vue实例，然后通过分别调用这个实例的事件触发和监听来实现通信和参数传递。

   - 新建一个js文件，来创建出我们的eventBus，我们把它命名为**bus.js** ；

     import Vue from 'vue';export default new Vue()；

   - 在click组件和show组件中import它：import Bus from 'common/js/bus.js'; 

   - 传递参数的组件中定义：Bus.$emit('getTarget', data);

   - 接收组件中定义：Bus.$on('getTarget', target => {
                 console.log(target);
             });

4. 使用vuex状态管理对数据进行统一管理

### -  vuex状态管理

用来读取的状态集中放在store中；改变状态mutations（同步的）；异步逻辑封装在action中；在mian.js引入store

场景：登录状态、加入购物车、单页面应用、组件之间的状态

5个组成

import {mapState, mapGetters, mapMutations，mapActions} from 'vuex'

mapState, mapGetters在computed里接收：...mapState(['hasLogin', 'account', 'target', 'shareFrom']),

mapMutations，mapActions在methods里接收：...mapMutations(['saveShareFrom', 'targetMember']),

1. 数据存储仓库：state：存放数据状态，不可以直接修改里面的数据

2. getters：类似vue的计算属性，用来过滤一些数据，与computed结合使用

   - 方法的第一个参数是state

     ```JavaScript
     getNum(state){ // 获取器离state很近，可以直接拿来用
         return state.num
       }
     // 组件中使用
     computed:{
       getMyNum(){
         return this.$store.getters.getNum
       }
     }
     ```

3. mutations：动态修改vuex的store中的状态或数据 - 增、删、改

   - 定义：里面的方法，第一个参数是state指向数据仓库，后面的参数是传入的数据；操作只能是同步的，否则可能丢失记录；组件中通过commit来调用

     ```JavaScript
     mutations:{
       addNum(state){
         state.num++
       },
     }
     
     this.$store.commit('addNum') //使用commit调用仓库的方法，写在methods函数中
     ```

4. actions：通过将mutations里面处理数据的方法，变成可以异步处理数据的方法，通过store.dispath来分发action

   - 有可能去发送请求，存在异步行为

     ```JavaScript
     // store.js中
     actions:{
       // $store.getters||commit||state,data
       // 接收的参数是整个store对象，或者使用解构赋值{commit}
       addByNumAction({commit}, num) {
         setTimeout(function () {
           commit('addByNum',num)
         }, 0)
       }
     }
     addByNumAction(){
       // 异步处理需要调用Action
       this.$store.dispatch('addByNumAction',5)
     }
     ```

5. modules：项目特别复杂时，可以让每一个模块拥有自己的state、mutation、action、getters，使得结构清晰，便于管理

### -  mixin

分发vue组件中可复用功能的灵活方式；可以定义共同的变量，在每个组件中使用；各个变量相互独立，值得修改不会相互影响

```JavaScript
// 定义
export const myMixin = {
    data () {
        return{
            num: 1
        }
    },
    created (){
        this.hello();
    },
    methods:{
        hello(){ /* ... */ }
    }
}
// 混入到当前组件中
import {myMixin} from '@/xxx/mixin.js'
export default {
    mixins: [myMixin],
}
```

**区别于vuex：**vuex用于状态管理，定义的变量在每个组件中均可修改，并且修改的值会改变

**区别于公共组件：**

- 组件：在父组件中引入组件，相当于在父组件中给出独立空间给子组件使用，然后根据props传值，相对独立
- mixin：在引入组件后与组件的对象方法进行合并，扩展了组件的对象和方法，形成新的组件

### - vue虚拟DOM

 虚拟DOM就是为了**解决浏览器性能问题**而被设计出来的。**如前**，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。**所以，**用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制。

 在实际代码中，会对新旧两棵树进行一个深度的遍历，每个节点都会有一个标记。每遍历到一个节点就把该节点和新的树进行对比，如果有差异就记录到一个对象中。 

 在JSX里为数组或枚举型元素增加上**key**后，它能够根据key，直接找到具体位置进行操作，效率比较高。 

**Diff算法**只是为了虚拟DOM比较替换效率更高，通过Diff算法得到diff算法结果数据表(需要进行哪些操作记录表)。原本要操作的DOM在vue这边还是要操作的，只不过用到了js的**DOM** **fragment**来操作dom（统一计算出所有变化后统一更新一次DOM）进行浏览器DOM一次性更新。

###  - computed & watch

 watch和computed都是以Vue的依赖追踪机制为基础，当某一个数据（称它为依赖数据）发生变化的时候，自动调用相关的函数去实现数据的变动。

methods用来定义函数，它需要手动调用才能执行，需要像”fuc()”这样去调用它（假设函数为fuc）

computed是计算属性，事实上和data对象里的数据属性是同一类的（使用上），在取值的时候，用this.fullName去取用，就和取data一样（不要当成函数调用！！）

watch和computed各自处理的数据关系场景不同 
1. watch擅长处理的场景：一个数据影响多个数据 ；

   1.是观察的动作， 

   2.应用：监听props，$emit或本组件的值执行异步操作 

   3.**无缓存性**，页面重新渲染时值不变化也会执行 

2. computed擅长处理的场景：一个数据受多个数据影响 

   1.是计算值， 

   2.应用：就是简化tempalte里面{{}}计算和处理props或$emit的传值 

   3.**具有缓存性**，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数 

**应用：**

1. 监听本组件计算和监听
2. 计算或监听父传子的props值
3. 分为简单数据类型和复杂数据类型监听
4. 监听vuex的state或者getters值的变化

**简单实现：**

```JavaScript 
function computed(ctx, obj) {
  let keys = Object.keys(obj)
  let dataKeys = Object.keys(ctx.data)
  dataKeys.forEach(dataKey => {
    defineReactive(ctx.data, dataKey, ctx.data[dataKey])
  })
  let firstComputedObj = keys.reduce((prev, next) => {
    ctx.data.$target = function() {
      ctx.setData({ [next]: obj[next].call(ctx) })
    }
    prev[next] = obj[next].call(ctx)
    ctx.data.$target = null
    return prev
  }, {})
  ctx.setData(firstComputedObj)
}

function watch(ctx, obj) {
  Object.keys(obj).forEach(key => {
    defineReactive(ctx.data, key, ctx.data[key], function(value) {
      obj[key].call(ctx, value)
    })
  })
}
```

参考：https://segmentfault.com/a/1190000012948175

### - props

常见错误：传入的值想作为局部变量来使用,直接使用会报错！！因为直接使用会改变父组件上的值，

解决：可以在data中重新定义一个变量,改变指向,但是也只是针对简单数据类型,因为复杂数据类型栈存贮的是指针 

###  - hash 和 history

对于 Vue 这类渐进式前端开发框架，为了构建 **SPA（单页面应用）**，需要引入前端路由系统，这也就是 Vue-Router 存在的意义。前端路由的核心，就在于 —— **改变视图的同时不会向后端发出请求**。

为了达到这一目的，浏览器当前提供了以下两种支持：

1. **hash** —— 即地址栏 URL 中的 `#` 符号（此 hash 不是密码学里的散列运算）。
   比如这个 URL：`http://www.abc.com/#/hello`，hash 的值为 `#/hello`。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。
2. **history** —— 利用了 HTML5 History Interface 中新增的 `pushState()` 和 `replaceState()` 方法。（需要特定浏览器支持）
   这两个方法应用于浏览器的历史记录栈，在当前已有的 `back`、`forward`、`go` 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。

因此可以说，hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由。

### - pwa渐进式web应用

谷歌公司将现有的技术，结合起来推广的一整套方案；

= 离线缓存，实现离线浏览，通过

- 静态资源的缓存
- 动态资源的缓存

策略：以缓存优先、以网络优先、以缓存或网络优先

一般简历上都要补上一句：持续关注PWA，积极研究其中应用场景。

- pwa核心是什么：serviceworker是什么？

  让用户用的更好，serviceworker是缓存的机器。

### -[ vue生命周期](https://segmentfault.com/a/1190000014640577)

从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程 

- beforeCreate：组件刚被创建，组件属性计算之前；

  this指向创建的实例；可以在这里添加loading事件；

  data computed watch methods上的方法和数据均不能访问 

- created：组件实例创建完成，

  完成数据(data props computed)的初始化 导入依赖项。 

  可访问data computed watch methods上的方法和数据 

  未挂载DOM,不能访问$el,$ref为空数组 

  可在这结束loading，还做一些初始化，实现函数自执行, 可以对data数据进行操作，可进行一些请求，请求不易过多，避免白屏时间太长。 

  若在此阶段进行的 DOM 操作一定要放在 Vue.nextTick() 的回调函数中 

- el属性：检查vue配置，即new vue{}里面的el是否存在，有就继续检查template项，没有则手动绑定调用vm.$mount（），

- beforeMount：模板编译，挂载之前，相关的render函数首次被调用

  有了el,编译了template|/outerHTML 

  能找到对应的template,并编译成render函数 

- mounted：编译、挂载，此时可以操作dom

  完成挂载DOM 和渲染;可在mounted钩子对挂载的dom进行操作 

  即有了DOM 且完成了双向绑定 可访问DOM节点,$ref 

  可在这发起后端请求，拿回数据，配合路由钩子做一些事情； 

- beforeUpdate：组件更新之前。<u>数据更新时调用</u>，发生在虚拟dom重新渲染之前，可以在这一步中进一步更改状态

  可在更新前访问现有的DOM,如手动移除添加的事件监听器； 

- updated：组件更新后

  可执行依赖的dom 操作 

  注意：不要在此函数中操作数据，会陷入死循环的。 

- activated：keep-alive组件激活时调用

  在使用vue-router时有时需要使用<keep-alive></keep-alive>来缓存组件状态，这个时候created钩子就不会被重复调用了， 如果我们的子组件需要在每次加载的时候进行某些操作，可以使用activated钩子触发 

- deactivated：keep-alive组件被移除时调用

- beforeDestroy：实例销毁之前调用，在这一步实例仍然完全可用

  在执行app.$destroy()之前 

  可做一些删除提示，如：你确认删除XX吗？  

  可用于销毁定时器，解绑全局时间 销毁插件对象 

- destroyed：实例销毁后调用，调用后，vue实例指示的所有东西都会解绑定，所有的事件监听器移除，子实例也被销毁。

  ```
  当前组件已被删除，销毁监听事件 组件 事件 子实例也被销毁
  这时组件已经没有了，你无法操作里面的任何东西了。
  ```

### - 子父组件的生命周期

仅当子组件完成挂载后，父组件才会挂载
当子组件完成挂载后，父组件会主动执行一次beforeUpdate/updated钩子函数（仅首次）
父子组件在data变化中是分别监控的，但是在更新props中的数据是关联的（可实践）
销毁父组件时，先将子组件销毁后才会销毁父组件

兄弟组件的初始化（mounted之前）分开进行，挂载是从上到下依次进行
当没有数据关联时，兄弟组件之间的更新和销毁是互不关联的

mixin中的生命周期与引入该组件的生命周期是仅仅关联的，且mixin的生命周期优先执行

### -[ 路由守卫](https://segmentfault.com/a/1190000013956945?utm_source=channel-newest)

**全局守卫：**

- router.beforeEach：当一个导航触发时，全局前置守卫按照创建顺序调用。 

  一般在这个守卫方法中进行全局拦截，比如必须满足某种条件（用户登录等）才能进入路由的情况 

- router.beforeResolve (v 2.5.0+)

  全局解析守卫

  和beforeEach类似，区别是在**导航被确认之前**，同时在所有**组件内守卫和异步路由组件被解析之后**，解析守卫就被调用
  即在 beforeEach 和 组件内beforeRouteEnter 之后

  参数和beforeEach一致，也需要调用next对导航确认

- router.afterEach

  全局后置钩子
  在所有路由跳转结束的时候调用
  这些钩子不会接受 next 函数也不会改变导航本身

- beforeEnter

  可直接定义在路由配置上，和beforeEach方法参数、用法相同

**组件内：**

- beforeRouteEnter

  在渲染该组件的对应路由被`确认`前调用，用法和参数与beforeEach类似，**next需要被主动调用**
  注意：

  - 此时组件实例还未被创建，不能访问this
  - 可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数

- beforeRouteUpdate：在当前路由改变，并且该组件被复用时调用，可以通过this访问实例， **next需要被主动调用，不能传回调** 

- beforeRouteLeave：导航离开该组件的对应路由时调用，可以访问组件实例 `this`，**next需要被主动调用，不能传回调** 

### - @click.native  @click.stop@click.prevent@keyup.enter

@click.native：如果使用router-link标签，加上@click事件，绑定的事件会无效因为：router-link的作用是单纯的路由跳转，会阻止click事件。此时加上**.native**，才会触发事件。

@click.stop 阻止事件冒泡

@click.prevent 阻止事件的默认行为

@keyup.enter   //按下enter时，执行方法test7

<input type="text" @keyup.enter="test7">

## **uni-app**

### - uni-app生命周期

1. **应用生命周期**
   - onlaunch：uni-app初始化完成
   - onshow：uni-app启动，或从后台进入前台
   - onHide：从前台进入后台
   - onUniNViewMessage：对nvue页面发送的数据进行监听
2. **页面生命周期**
   - onLoad：监听页面加载，
   - onshow：监听页面显示
   - onReady：监听页面初次渲染完成
   - onHide：监听页面隐藏
   - onUnload：监听页面卸载
   - onPullDownRefresh：监听用户下拉动作，一般用于下拉刷新
   - onReachBottom：页面上拉触底事件的处理函数
   - onShareAPPMessage：用户点击右上角分享
   - onPageScroll：监听页面滚动
   - onNavigationBarButtonTap：监听原生标题栏按钮点击事件
   - onBackPress：监听页面返回

### - nuxt.js（SSR Server Site Render）服务端渲染

服务端渲染根据请求的url，动态的将模板与数据结合，并响应给客户端。

nuxt.js是帮助vue轻松完成服务端渲染工作的框架。它预设了服务端渲染所需要的各种配置，如异步数据、中间件、路由，好比：angular ungular之于angular，next.js之于react。

解决了SEO的问题，当百度搜索引擎爬虫爬取的时候，通过url产生对服务器的请求，服务器根据url响应页面，因此百度就获取到了我们站点的数据。

刷新、地址栏回车：url改变，服务端渲染

点击next-link组件，点击a标签，禁止a标签的页面跳转，并根据其href属性，通过history.pushState改变地址栏，并发起请求或者具体的客户端渲染行为，局部替换内容。

## **jQuery & bootstrap**

Bootstrap是基于HTML5和CSS3开发的，它在jQuery的基础上进行了更为个性化和人性化的完善，只需要给标签起上响应的Class名称，就可以形成一套Bootstrap自己独有的网站风格，并兼容大部分jQuery插件。

(1) jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。
(2) jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等。

(3) jQuery本身注重于后台，没有漂亮的界面，而jQuery UI则补充了前者的不足，他提供了华丽的展示界面，使人更容易接受。既有强大的后台，又有华丽的前台。jQuery UI是jQuery插件，只不过专指由jQuery官方维护的UI方向的插件。



## **react**

### 1 diff算法

- 判断两棵virtual DOM Tree差异
- 把差异更新到真实DOM中去

### 2 virtual DOM算法实现

- 通过js来模拟生成virtual DOM Tree
- 判断两个Tree的差异
- 渲染差异

## **计算机网络基础相关**

### -   web开发中会话跟踪的方法有哪些

1. cookie
2. session
3. url重写
4. 隐藏input
5. ip地址

### -   发送HTTP method

1. 一台服务器要与HTTP1.1兼容，只要为资源实现**GET**和**HEAD**方法即可
2. **GET**是最常用的方法，通常用于**请求服务器发送某个资源**。
3. **HEAD**与GET类似，但**服务器在响应中值返回首部，不返回实体的主体部分**
4. **PUT**让服务器**用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它**
5. **POST**起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。
6. **TRACE**会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。
7. **OPTIONS**方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。
8. **DELETE**请求服务器删除请求URL指定的资源

### -   输入url到显示页面

1. 在浏览器地址栏输入URL

2. 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤
   1. 如果资源未缓存，发起新请求
   2. 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。
   3. 检验新鲜通常有两个HTTP头进行控制 Expires 和 Cache-Control
      - HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期
      - HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间
   
3. 浏览器**解析URL**获取协议，主机，端口，path

4. 浏览器**组装一个HTTP（GET）请求报文**

5. 浏览器获取主机ip地址，过程如下：
   1. 浏览器缓存
   2. 本机缓存
   3. hosts文件
   4. 路由器缓存
   5. ISP DNS缓存
   6. DNS递归查询（可能存在负载均衡导致每次IP不一样）
   
6. 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：
   1. 客户端发送一个TCP的**SYN=1，Seq=X**的包到服务器端口
   2. 服务器发回**SYN=1， ACK=X+1， Seq=Y**的响应包
   3. 客户端发送**ACK=Y+1， Seq=Z**
   
7. TCP链接建立后**发送HTTP请求**

8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序

9. 服务器检查**HTTP请求头是否包含缓存验证信息**如果验证缓存新鲜，返回**304**等对应状态码

10. 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作

11. 服务器将**响应报文通过TCP连接发送回浏览器**

12. 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下
    1. 主动方发送**Fin=1， Ack=Z， Seq= X**报文
    2. 被动方发送**ACK=X+1， Seq=Z**报文
    3. 被动方发送**Fin=1， ACK=X， Seq=Y**报文
    4. 主动方发送**ACK=Y， Seq=X**报文
    
13. 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同

14. 如果资源可缓存，**进行缓存**

15. 对响应进行**解码**（例如gzip压缩）

16. 根据资源类型决定如何处理（假设资源为HTML文档）

17. **解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本**，这些操作没有严格的先后顺序，以下分别解释

    - 构建DOM树

    1. **Tokenizing**：根据HTML规范将字符流解析为标记
    2. **Lexing**：词法分析将标记转换为对象并定义属性和规则
    3. **DOM construction**：根据HTML标记关系将对象组成DOM树

    - 解析过程中遇到图片、样式表、js文件，**启动下载**

    - 构建CSSOM树

    1. **Tokenizing**：字符流转换为标记流
    2. **Node**：根据标记创建节点
    3. **CSSOM**：节点创建CSSOM树

    - [根据DOM树和CSSOM树构建渲染树](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction)

    1. 从DOM树的根节点遍历所有**可见节点**，不可见节点包括：1）`script`,`meta`这样本身不可见的标签。2)被css隐藏的节点，如`display: none`
    2. 对每一个可见节点，找到恰当的CSSOM规则并应用
    3. 发布可视节点的内容和计算样式

    - js解析如下

    1. 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时**document.readystate为loading**
    2. HTML解析器遇到**没有async和defer的script时**，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。**同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容**
    3. 当解析器遇到设置了**async**属性的script时，开始下载脚本并继续解析文档。脚本会在它**下载完成后尽快执行**，但是**解析器不会停下来等它下载**。异步脚本**禁止使用document.write()**，它们可以访问自己script和之前的文档元素
    4. 当文档完成解析，document.readState变成interactive
    5. 所有**defer**脚本会**按照在文档出现的顺序执行**，延迟脚本**能访问完整文档树**，禁止使用document.write()
    6. 浏览器**在Document对象上触发DOMContentLoaded事件**
    7. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些**内容完成载入并且所有异步脚本完成载入和执行**，document.readState变为complete,window触发load事件

23. **显示页面**（HTML解析过程中会逐步显示页面）

### -  页面渲染过程

1、**构建DOM树（parse）：**渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node（包括js生成的标签）生成内容树（Content Tree/DOM Tree）；

2、**构建渲染树（construct）：**解析对应的CSS样式文件信息（包括js生成的样式和外部css文件），而这些文件信息以及HTML中可见的指令（如<b></b>），构建渲染树（Rendering Tree/Frame Tree）；

3、**布局渲染树（reflow/layout）：**从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；

4、**绘制渲染树（paint/repaint）：**遍历渲染树，使用UI后端层来绘制每个节点。

### - http协议特点

1.支持客户/服务器模式。

2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。

4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

### [- HTTP相关](D:\文件\前端\笔记\计算机网络基础\http相关&HTTPS.md)websocket、https、http2

**HTTPS：**HTTPS = HTTP+加密+认证+完整性保护

它的加密过程是：

1. server生成一个公钥和私钥，把公钥发送给第三方认证机构（CA）；
2. CA把公钥进行MD5加密，生成数字签名；再把数字签名用CA的私钥进行加密，生成数字证书。CA会把这个数字证书返回给server；
3. server拿到数字证书之后，就把它传送给浏览器；
4. 浏览器会对数字证书进行验证，首先，浏览器本身会内置CA的公钥，会用这个公钥对数字证书解密，验证是否是受信任的CA生成的数字证书；
5. 验证成功后，浏览器会随机生成对称秘钥，用server的公钥加密这个对称秘钥，再把加密的对称秘钥传送给server；
6. server收到对称秘钥，会用自己的私钥进行解密，之后，它们之间的通信就用这个对称秘钥进行加密，来维持通信。

HTTP是基于TCP/IP协议的应用层协议，用于客户端和服务器之间的通信，默认80端口。 

### -[ 状态码](D:\文件\前端\笔记\计算机网络基础\状态码详解.md)

### -   HTTP request请求报文、response响应报文结构

1. 首行是**Request-Line**包括：**请求方法**，**请求URI**，**协议版本**，**CRLF**
2. 首行之后是若干行**请求头**，包括**general-header**，**request-header**或者**entity-header**，每个一行以CRLF结束
3. 请求头和消息实体之间有一个**CRLF分隔**
4. 根据实际请求需要可能包含一个**消息实体** 一个请求报文例子如下：

1. 首行是状态行包括：**HTTP版本，状态码，状态描述**，后面跟一个CRLF
2. 首行之后是**若干行响应头**，包括：**通用头部，响应头部，实体头部**
3. 响应头部和响应实体之间用**一个CRLF空行**分隔
4. 最后是一个可能的**消息实体** 响应报文例子如下：

### -  XSS和CSRF防范措施 

  （1）XSS：跨站脚本攻击 

  攻击方式：在URL或者页面输入框中插入JavaScript代码。 

  防范： 

-    设置httpOnly，禁止用document.cookie***作；    
-    输入检查：在用户输入的时候进行格式检查；    
-    对输出转义。   

  （2）CSRF：跨站点伪造请求 

  攻击方式：攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些***作（如发邮件，发消息，甚至财产***作如转账和购买商品）。主要是拿到了用户的登录态。 

  防范： 

-    **检查 Referer 字段**：这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer 字段应和请求的地址位于同一域名下。    
-    **添加校验 Token**：这种数据通常是表单中的一个数据项。服务器生成token并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过 CSRF 传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验 Token 的值为空或者错误，拒绝这个可疑请求。    
-    **通过输入验证码来校验合法请求**。

## **综合设计问题**

### - 设计模式

https://www.nowcoder.com/discuss/123161

（1）单例模式 

  定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 

  实现方法：先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。 

  适用场景：一个单一对象。比如：弹窗，无论点击多少次，弹窗只应该被创建一次。 

  （2）发布/订阅模式
 定义：又叫观察者模式,它定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都将得到通知。 

  场景：订阅感兴趣的专栏和公众号。 

  （3）策略模式
 定义：将一个个算法（解决方案）封装在一个个策略类中。 

  优点： 

- 策略模式可以避免代码中的多重判断条件。    

- 策略模式很好的体现了开放-封闭原则，将一个个算法（解决方案）封装在一个个策略类中。便于切换，理解，扩展。    

- 策略中的各种算法可以重复利用在系统的各个地方，避免复制粘贴。    

- 策略模式在程序中或多或少的增加了策略类。但比堆砌在业务逻辑中要清晰明了。    

- 违反最少知识原则，必须要了解各种策略类，才能更好的在业务中应用。   

  应用场景：根据不同的员工绩效计算不同的奖金；表单验证中的多种校验规则。 

  （4）代理模式 

  定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。 

  应用场景：图片懒加载（先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。） 

  （5）中介者模式 

  定义：通过一个中介者对象，其他所有相关对象都通过该中介者对象来通信，而不是互相引用，当其中的一个对象发生改变时，只要通知中介者对象就可以。可以解除对象与对象之间的紧耦合关系。 

  应用场景： 例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发change事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。 

  （6）装饰者模式 

  定义：在不改变对象自身的基础上，在程序运行期间给对象动态的添加方法。 

  应用场景： 有方法维持不变，在原有方法上再挂载其他方法来满足现有需求；函数的解耦，将函数拆分成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，实现相同的效果但增强了复用性。 

  参考： [JavaScript设计模式](https://juejin.im/post/59df4f74f265da430f311909)

### - 前后端数据交互的流程

### - 如何设计注册登录流程

### 1. 图片懒加载怎么实现 

  **场景**：一个页面中很多图片，但是首屏只出现几张，这时如果一次性把图片都加载出来会影响性能。这时可以使用懒加载，页面滚动到可视区在加载。优化首屏加载。 

  **实现**：img标签src属性为空，给一个data-xx属性，里面存放图片真实地址，当页面滚动直至此图片**出现在可视区域**时，用js取到该图片的data-xx的值赋给src。 

  **优点**：页面加载速度快，减轻服务器压力、节约流量，用户体验好。

**可视区域的计算：**

```JavaScript 
获取img节点距离浏览器顶部的距离，如果小于或等于浏览器窗口的可视高度，那么就将data-xx的值赋值到src里去
getBound(el) {
    let bound = el.getBoundingClientRect();
    let clientHeight = window.innerHeight;
    // 图片距离顶部的距离 <= 浏览器可视化的高度，从而推算出是否需要加载
    return bound.top <= clientHeight - 100; // -100是为了看到效果，您也可以去掉
  }
```

```
页可见区域宽： document.body.clientWidth;
网页可见区域高： document.body.clientHeight;
网页可见区域宽： document.body.offsetWidth (包括边线的宽);
网页可见区域高： document.body.offsetHeight (包括边线的宽);
网页正文全文宽： document.body.scrollWidth;
网页正文全文高： document.body.scrollHeight;
网页被卷去的高： document.body.scrollTop;
网页被卷去的左： document.body.scrollLeft;
网页正文部分上： window.screenTop;
网页正文部分左： window.screenLeft;
屏幕分辨率的高： window.screen.height;
屏幕分辨率的宽： window.screen.width;
屏幕可用工作区高度： window.screen.availHeight;
```

```
//父容器高度（可视） = 设备高度 - 父容器的top
this.wrapperHeight = document.documentElement.clientHeight
  - this.$refs.wrapper.getBoundingClientRect().top
```

### 2 前端性能优化方案

- 内容优化

  ```
  (1)减少HTTP请求数:合并文件、CSS精灵、inline Image √
  (2)减少DNS查找：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询
  (3)避免重定向=多次请求
  (4)使用Ajax缓存 √
  (5)非必须组件延迟加载
  (6)减少DOM元素数量:页面中存在大量DOM元素,会导致javascript遍历DOM的效率变慢。√
  (7)最小化iframe的数量
  (8)避免404：HTTP请求时间消耗是很大的，因此使用HTTP请求来获得一个没有用处的响应（例如404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。
  ```

- 服务器优化

  ```
  (1)使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。
  (2)对组件使用GZIP压缩
  (3)设置ETag：ETags（Entity tags，实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。
  (4)提前刷新缓冲区
  (5)对Ajax请求使用GET方法
  (6)避免空的图像src
  ```

- Cookie优化

  ```
  (1)减小Cookie大小 √
  (2)针对Web组件使用域名无关的Cookie
  ```

- CSS优化

  ```
  (1)将CSS代码放在HTML页面的顶部 √
  (2)避免使用CSS表达式
  (3)使用<link>来代替@import 
  (4)避免使用IE的Filters
  (5)将需要频繁进行DOM操作的元素position设置为absolute或fixed，脱离文档流，使其尺寸的改变不会影响到文档流中的元素，避免回流、重绘的影响。√
  ```

- javascript优化

  ```
  (1)将JavaScript脚本放在页面的底部。√
  (2)将JavaScript和CSS作为外部文件来引用：在实际应用中使用外部文件可以提高页面速度，因为JavaScript和CSS文件都能在浏览器中产生缓存。√
  (3)缩小JavaScript和CSS
  (4)删除重复的脚本
  (5)最小化DOM的访问：如果要连续对某个DOM进行操作，引起回流，可以先将元素display：none，然后进行统一的修改，全部修改完成再display：block进行呈现。√
  (6)开发智能的事件处理程序
  (7)javascript代码注意：谨慎使用with,避免使用eval Function函数,减少作用域链查找。
  ```

- 图像优化

  ```
  (1)优化图片大小
  (2)通过CSS Sprites优化图片√
  (3)不要在HTML中使用缩放图片
  (4)favicon.ico要小而且可缓存
  ```



### 3 轮播图实现过程（如何封装为一个组件，实现重复利用）

第一种：

把图片名称按顺序取好名字，利用定时器，每隔多少秒，更换图片的路径

第二种：

​       利用无缝滚动的技术，把图片都放入页面中，定时器进行scroll滚动，判断滚动距离取余(%) 图片宽度等于0，暂停定时器，多少秒后再开启定时器。

### [4 如何封装插件](https://segmentfault.com/a/1190000010813937)

**组件：**calender/Alert/loading

**插件：**vue-router/vuex/vux

**关系：**插件可以封装，组件可以暴露给插件

**插件分类：**

1. 添加全局方法或属性，如vue-element
2. 添加全局资源：指令/过滤器/过渡等，如vue-touch
3. 通过全局mixin方法添加一些组件选项，如vuex
4. 添加Vue实例方法，通过他们添加到vue.prototype上实现

以上四种方法的绑定机制如下：

```JavaScript 
export default {
    install(Vue, options) {
        Vue.myGlobalMethod = function () {  // 1. 添加全局方法或属性，如:  vue-custom-element
            // 逻辑...
        }

        Vue.directive('my-directive', {  // 2. 添加全局资源：指令/过滤器/过渡等，如 vue-touch
            bind (el, binding, vnode, oldVnode) {
                // 逻辑...
            }
            ...
        })
    
        Vue.mixin({
            created: function () {  // 3. 通过全局 mixin方法添加一些组件选项，如: vuex
                // 逻辑...
            }
            ...
        })    
    
        Vue.prototype.$myMethod = function (options) {  // 4. 添加实例方法，通过把它们添加到 Vue.prototype 上实现
            // 逻辑...
        }
    }
}
```

install是注册插件主要调用的方法，包含了两个参数（Vue实例和自定义配置属性options），我们可以将以上代码存储到plugins.js中。 

通过全局方法 Vue.use() 即可使用该插件，其自动会调用install方法。Vue.use会自动阻止注册相同插件多次，届时只会注册一次该插件。 

### 6 loading的实现

loading插件

```JavaScript 
<!-- loading.vue组件 -->
<template>
    <div class="loading-box" v-show="show">
        <div class="loading-mask"></div>
        <div class="loading-content">
            <div class="animate">
            </div>
            <div class="text">{{text}}</div>
        </div>
    </div>
</template>

<script>
export default {
    props: {
        show: Boolean,
        text: {
          type: String,
          default: '正在加载中...'
        },
    }
}
</script>
```

以上是一个loading.vue组件，省略了样式部分，在没有封装插件之前，我们只能通过import引入并注册到components对象中才能在页面中使用，如：

```JavaScript 
<template>
    <div>
        <loading :show="true"></loading>
    </div>
</template>
<script>
import Loading from './loading.vue'

export default {
    ...
    
    components: {
        Loading
    }
    
    ...
}
</script>
```

下面我们便来封装一下该组件：

```JavaScript 
// loading.js
import LoadingComponent from '../components/loading.vue'

let $vm

export default {
    install(Vue, options) {
        if (!$vm) {
            const LoadingPlugin = Vue.extend(LoadingComponent);

            $vm = new LoadingPlugin({
                el: document.createElement('div')
            });

            document.body.appendChild($vm.$el);
        }

        $vm.show = false;

        let loading = {
            show(text) {
                $vm.show = true;

                $vm.text = text;
            },
            hide() {
                $vm.show = false;
            }
        };

        if (!Vue.$loading) {
            Vue.$loading = loading;
        }

        // Vue.prototype.$loading = Vue.$loading;

        Vue.mixin({
            created() {
                this.$loading = Vue.$loading;
            }
        })
    }
}
```

以上我们新建一个loading.js文件，引入我们的loading.vue组件，然后通过Vue.extend()方法创建了一个构造器LoadingPlugin，其次我们再通过new LoadingPlugin()创建了$vm实例，并挂载到一个div元素上。最后我们需要通过document.body.appendChild($vm.$el)将其插入到DOM节点中。

当我们创建了$vm实例后，我们可以访问该实例的属性和方法，比如通过$vm.show就可以改变loading组件的show值来控制其显示隐藏。

最终我们通过Vue.mixin或者Vue.prototype.$loading来全局添加了$loading事件，其又包含了show和hide两个方法。我们可以直接在页面中使用this.$loading.show()来显示加载，使用this.$loading.hide()来关闭加载。

### 7 登录设计及cookie应用

1. **注册过程中会经历的步骤和过程**有以下几点： 

   - 用户输入正确格式的邮箱、用户名和密码并点击注册。
   - 前端页面**判断**用户输入的信息的格式**是否正确和合法。**
   - 客户端把这些信息提交至服务器端，服务器**获取全部内容**并**提取需要的信息。**
   - 服务器端对这些信息进行**再次的判断**，判断用户输入的信息的格式是否正确和合法，以及与数据库中的已有信息作比较，判断相关信息**是否已经被注册。**
   - 若判断后发现没有问题，则返回客户端HTTP状态码200表示注册成功，并**把新注册用户的信息写入数据库内**，若发现问题，则返回HTTP状态码400和对应的错误信息表示注册失败。
   - 客户端收到状态码展示对应的内容

2. **登录过程中会经历的步骤和过程**有以下几点： 

   - 用户输入正确格式的用户名和密码并点击登录。
   - 前端页面**判断**用户输入的信息的格式**是否正确和合法。**
   - 客户端把这些信息提交至服务器端，服务器**获取全部内容并提取需要的信息。**
   - 服务器端对这些信息进行**再次的判断**，判断用户输入的信息的格式是否正确和合法，并**与数据库中的已注册账户信息进行核对**，看看对应的用户名和密码是否相等。
   - 若核对发现信息相等，则**设置Cookie**，并返回客户端HTTP状态码200表示注册成功，若核对失败，则返回HTTP状态码401和对应的错误信息表示注册失败。
   - 客户端若收到401状态码，则提示用户登录失败，并展示对应错误信息，若收到200状态码，则**带上收到的Cookie对首页的url发起请求**。
   - 服务器收到请求后**解析请求所携带的Cookie**，提取出Cookie所包含的用户的信息。
   - 把首页中的部分公共信息更替为该用户自己的个人信息，并把更替好的内容返回给客户端。
   - 客户端向用户展示返回的内容。

   > **前端可以不判断和验证注册以及登录的内容，但是后端必须要添加验证，因为用户可以通过在命令行使用curl发送请求，这样会跨过浏览器的验证，因此后端的验证是必须要存在的。** 

   

   **cookie实现记得登录状态免登录**

```JavaScript 
// 如果有登录框存在，默认把它隐藏掉
$("#dialog-login").hide();

var cookie_key = "cphone";

/**
 * 设置cookie
 * 
 * @param ckey
 * @param cvalue  
 * @param exdays 过期天数
 * @returns
 */
function setCookie(ckey, cvalue, exdays){
    var d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    var expires = "expires=" + d.toGMTString();
    document.cookie = ckey + "=" + cvalue + "; " + expires;
}

/**
 * 通过key获取cookie的value
 * 
 * @param ckey
 * @returns
 */
function getCookie(ckey){
    var key = ckey + "=";
    var ca = document.cookie.split(';');
    for(var i = 0; i < ca.length; i++) {
        var c = ca[i].trim();
        if (c.indexOf(key) == 0) { 
        	return c.substring(key.length, c.length); 
        }
    }
    return "";
}

/**
 * 检测cookie是否存在
 * 
 * @param ckey
 * @returns
 */
function checkCookie(ckey){
	var cvalue = getCookie(ckey);
	// 有数值才叫存在
    if (cvalue != ""){
        return true;
    }
    else {
        return false;
    }
}

/**
 * 删除cookie
 * 就是设置cookie值为"" (cookie还存在)
 */
function deleteCookie() {
	// 设置cookie值位""
	setCookie(cookie_key, "", 100); 
}

/**
 * 如果cookie存在，供onload函数调用。
 * 
 * @param cookie中的cphone值
 * 
 */
function onloadInteract(cvalue) {
	$.ajax({
		url: "onload",
		type: "post",
		contentType: "application/x-www-form-urlencoded;charset=utf-8",
		data:{
			"phone": cvalue
		},
		dataType: "json",
		success: function (data) {		
			console.log("哦耶登录成功！");
			
		},
		error:function(data){
		}
	});
}

/**
 * 登录函数
 */
function login() {
	....
	// 登录成功，设置cookie
	var cvalue = xxx;
	// 有效期365天，默认不设置天数的话，关闭浏览器就过期
	setCookie(cookie_key, cvalue, 365);
	console.info("成功设置了cookie");	
}
/**
 * 网页加载调用函数
 * 检查是否存在cookie，存在就不用登录了，登录框都不显示
 */
window.onload = function() {
	// 默认隐藏登陆框
	$("#dialog-login").hide();
	console.info("进入onload函数");
	/* @chl16
	 * 检测cookie 
	 */
	if (checkCookie(cookie_key)) {
		// cookie存在
		console.info("cookie存在:");
		
		// 直接通过phone交互
		onloadInteract(getCookie(cookie_key));
		
	} else {
		console.log("cookie不存在");
		$("#dialog-login").show();
		// 显示函数
		showMask(); 
	}
}

/**
 * 退出登录函数
 */
function exit(){
	/*
	 * @chgl16 
	 * 退出登陆，删除cookie
	 */
	deleteCookie();

	....
}
```



### 8  [骨架屏](https://blog.csdn.net/sinat_17775997/article/details/83443744)

```
用户大概会在 200ms 内获取到界面的具体关注点，在数据获取或页面加载完成之前，给用户首先展现骨架屏，骨架屏的样式、布局和真实数据渲染的页面保持一致，而在用户的感知上，出现骨架屏那一刻数据已经获取到了，而后只是数据渐进式的渲染出来。这样用户感知页面加载更快了。
 React、Vue、Angular 都是 JS 驱动，在 JS 代码解析完成之前，页面不会展示任何内容，也就是所谓的白屏。Vue 来说，在应用启动时，Vue 会对组件中的 data 和 computed 中状态值通过 Object.defineProperty 方法转化成 set、get 访问属性，以便对数据变化进行监听。而这一过程导致页面启动阶段比非 JS 驱动（比如 jQuery 应用）的页面要慢一些
```
**方法一：手写骨架屏**

缺点：每次需求更改都会产生巨大的修改工作量，维护成本增加

1. 基于预渲染来实现骨架屏，首先配置webpack-plugin，有一个现成的[prerender-spa-plugin](http://link.zhihu.com/?target=https%3A//github.com/chrisvfritz/prerender-spa-plugin)插件可用

2. 写好与要展现的页面对应的骨架屏组件，vue文件，并通过css动画来实现骨架屏的动效。

3. 进入页面时，先展示骨架屏，数据加载完毕，在mounted生命周期中移除骨架屏。

   1. ``` JavaScript
      var path = require('path')
      var PrerenderSpaPlugin = require('prerender-spa-plugin')
       
      module.exports = {
        // ...
        plugins: [
          new PrerenderSpaPlugin(
            // Absolute path to compiled SPA
            path.join(__dirname, '../dist'),
            // List of routes to prerender
            ['/']
          )
        ]
      }
      ```

   2. ```javascript
      
          <mainSkeleton v-if="!init"></mainSkeleton>
          <div v-else>
            <div class="body"></div>
          </div>
      ...
      <script>
       import mainSkeleton from './main.skeleton.vue'
              init: false
            
          mounted () {
            setTimeout(() => {    //  这里模拟数据请求
              this.init = true
            }, 250)
          },
          components: {
            mainSkeleton
          }
        }
      </script>
     ```

**方法二：SSR服务端渲染**

优点：有利于SEO，加快内容呈现

缺点：需要构建服务、部署，考虑服务器负载，以及相应的缓存策略

大致过程：https://www.jb51.net/article/130505.htm

1. 创建skeleton.entry.js，事先写好的骨架屏组件
2. 创建webpack.ssr.conf.js文件，将skeleton.entry.js文件编译成服务端可用的bundle文件
3. 编写vue-server-renderer来渲染bundle，产出响应的html片段和css片段
4. 对html和css片段进行组装，生成最终的html，需要监听webpack 的编译挂载之前的事件（具体见上方链接）

**方法三：prerender预渲染**

在项目构建过程中通过渲染机制，如 [puppeteer](https://github.com/GoogleChrome/puppeteer)或则 [jsdom](https://npmjs.com/package/jsdom) 将页面在构建的过程中就渲染好，然后插入到 html 中，这样在页面启动之前首先看到的就是预渲染的页面了。

缺点：预渲染渲染的页面数据是在构建过程中就已经打包到了 html 中， 当真实访问页面的时候，真实数据可能已经和预渲染的数据有了很大的出入

**最终方案：**

```
通过 puppeteer 在服务端操控 headless Chrome 打开开发中的需要生成骨架屏的页面，在等待页面加载渲染完成之后，在保留页面布局样式的前提下，通过对页面中元素进行删减或增添，对已有元素通过层叠样式进行覆盖，这样达到在不改变页面布局下，隐藏图片和文字，通过样式覆盖，使得其展示为灰色块。然后将修改后的 HTML 和 CSS 样式提取出来，这样就是骨架屏了。
```











