[TOC]

# js基础查漏补缺

[深入理解http协议的特点]



HTTP 是一个属于应用层的面向对象的协议，HTTP 协议一共有五大特点：1、支持客户/服务器模式；2、简单快速；3、灵活；**4、无连接；5、无状态**。

## js运算符

### 关系运算符

1. +/-：

   ```JavaScript
   var num=2345;
   console.log(typeof num);//number
   num=num+"";	//数字加空字符串，可以转为string类型
   console.log(typeof num);//string
   num=num-0;	//字符串转数值
   console.log(typeof num);//number
   ```

2. 数值与数值比较的是他们的代数值

   - 字符串比较：逐个比较unicode数值

   - 字符串与非数值比较：运算数转换成字符串进行比较

   - 运算数非数字也非字符串：转换为数值或字符串

   - 运算数无法转换为数值或字符串：返回值为FALSE

   + 与NAN的比较：返回为FALSE

3. ==/!=：比较两个运算数的**返回值**是否相等

   ===/!==：比较两个运算数的**返回值及数据类型**是否不同

4. null&undefined：相等，比较前不进行任何转换

   **NaN：与任何数值都不相等包括自身**

5. 引用类型之间的比较：比较他们的引用值（内存地址）

### 逻辑运算符

- ！逻辑非

- &&：逻辑与
- ||：逻辑或

### 位运算符

- 有符号：数值位：前31位

  ​	       符号位：第32位；0→正数，1→负数

- 无符号：只能是正数；32位都是数值

  （-2147483648~2147483647）

- 存储方式：正数：纯二进制存储；用0补充无用位

  ​		  负数：2进制补码存储（反码加1)

- 当做0处理的特殊值：NaN、Infinity

### 逻辑位运算

- 返回值为1:
  - ~：按位非：0
  - &：按位与：对应位1
  - |：按位或：任何一位1
  - \^：按位异或：既不同为0也不同为1
- 返回值0：
  - ~：按位非：1
  - &：按位与：任何一位0
  - |：按位或：对应位全0
  - \^：按位异或：对应位全0或1
- 位移：
  - 左移<<：空位补0
  - 有符号右移>>：移出位舍弃；保留符号位
  - 无符号右移>>>：正数与上相同；负数会出现无限大的数值
- 复合赋值运算符：位操作符与=结合，赋值不会有性能的提升

### 其他运算符

- ？：简洁的if-else
- typeof：类型判断运算符
- ，：一行语句中执行不同的操作
- void：舍弃运算数的值，返回undefined作为表达式的值

## avaScript数组

## regexp正则

### 正则RegExp构造函数属性

关于属性的定义，我在这里在重新提一下：

input (简写为$_) 最近一次要匹配的字符串。

lastMatch(简写$&) 最近一次的匹配项

lastParen(简写$+) 最近一次匹配的捕获组。

leftContext(简写$`) input字符串中lastMatch之前的文本

rightContext(简写$') input字符串中lastMatch之后的文本

multiline(简写$*) 布尔值，表示是否所有表达式都使用多行模式。

#### 举例说明

看定义太痛苦了，我们还是举个例子来看下。

```JavaScript
var text ="you are in haorooms 博客，看文章呢";
var pattern =/(.)aorooms/g;
if(pattern.test(text)){
   console.log(RegExp.$_); //you are in haorooms 博客，看文章呢
   console.log(RegExp["$`"]);//you are in
   console.log(RegExp["$'"]);//博客，看文章呢
   console.log(RegExp["$&"]);//haorooms
   console.log(RegExp["$+"]);//h
   console.log(RegExp["$*"]);//false
}
```

### 字符组

`[]`字符组表示在同一个位置可能出现的各种字符，也就是说它的匹配结果只能是一个字符，不能是多个

例如`[hello]`匹配的不是`hello`而是`h或e或l或o`

#### 特点

- 结果只会匹配一个字符
- 内部特殊字符无需转义`\` `[` `]` 除外
  - 另外，`^`出现在最开始位置时需要转义
  - `-`前后构成区间范围时需要转义（推荐永远使用转义`\-`）
- `-`表示连字符
- `^`表示排除符

#### 示例

**特殊字符无需转义**

```
[\^*\-+|(a)]
```

这个示例的含义是，匹配以下字符中的任意一个

- `^` `*` `-` `+` `|` `(` `a` `)`
- 可以看到，这些特殊字符在字符组中仅仅就是字符本身

**连字符的作用**

```JavaScript
[z-a]
```

- 匹配这个正则表达式会报错（`Range out of order in character class`）

- 原因是连字符后面的字符码要大于等于前面的字符码

**排除型**

```JavaScript
var str = '01ABabc-';
var reg = /[^a-z]/g;

// 匹配了除a-z范围外的任意字符
str.match(reg); // ["0", "1", "A", "B", "-"]
```

**\b特殊情况**

\b只是匹配字符串开头结尾及空格回车等的位置, 不会匹配空格符本身 

\b代表字与字中间那个看不见的东西，如

here is a word
那么，这句中有好几个\b, 每个单词的前后都有一个\b.

所以你用 \bhere\b 可以匹配上面这个here,但如果here 不是一个单词，而是一个单词的一部分，如 adheread, 这样的话，用here 可以匹配，用\bhere\b就不能区配了，因为ad后面没有\b. 所以 adhere 中的here 不会被匹配。 

总结： \b 就是用在你匹配整个单词的时候。 如果不是整个单词就不匹配。 你想匹配 I 的话，你知道，很多单词里都有I的，但我只想匹配I，就是“我”，这个时候用 \bI\b

```
var str = 'ab\bd,cdef';
var reg = /[\b]/g;
var reg2 =  /\bc/g; 
var reg3 =  /[\b]c/g; 

str.match(reg); // [""] 匹配\b本身
str.match(reg2); // ["c"]  即匹配,号后面的c
str.match(reg3); // null 因为\b后面没有c
```

- `\b`在字符组以外表示单词边界
- 在字符组内，表示退格符(`\b`)

### 捕获组

捕获组就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用

例如: `/(a)(b)(c)/`中的捕获组编号为

- 组`0`: `abc`
- 组`1`: `a`
- 组`2`: `b`
- 组`3`: `c`

其中，组`0`是正则表达式整体匹配结果，组`1``2``3`才是子表达式匹配结果

#### 示例

**子表达式捕获组编号从1开始，顺序从左到右**

```JavaScript
var str = "2017-07-29";
var reg = /(\d{4})-(\d{2})-(\d{2})/;

// 非全局模式有捕获组结果
str.match(reg); // ["2017-07-29", "2017", "07", "29", index: 0, input: "2017-07-29"]
```

| 编号 | 捕获组               | 匹配内容   |
| :--- | :------------------- | :--------- |
| 0    | (d{4})-(d{2})-(d{2}) | 2017-07-29 |
| 1    | d{4}                 | 2017       |
| 2    | d{2}                 | 07         |
| 3    | d{2}                 | 29         |

### **JS程序内的引用**

- 在`replace`中，`JS`通过`$number`引用捕获组内容
- 在外部匹配引用，`JS`通过`RegExp.$number`引用捕获组内容

```JavaScript
var str = '<div id="code1" class="highlight"></div>';
var reg = /<(\w+)[^>]*>/g;
// <div></div>
str = str.replace(reg, "<$1>");
```

*可以看到，在去除`div`中的属性时，先是整个匹配`<divxxx>`，然后再把整个内容替换成`<$1>`，其中`$1`就是第一个捕获组结果`div`的引用*

注，请不要引用`$0`，因为它不属于子表达式的捕获组，在`replace`中引用`$0`没有任何效果

### 反向引用

在正则表达式内部对捕获组进行引用称之为反向引用

```JavaScript
var str = "boom==boom";
var reg = /(boom)==\1/;

str.match(reg); // ["boom==boom", "boom", index: 0, input: "boom==boom"]
```

可以看到，正则中**`\1`的值就是捕获组`1`匹配到的结果**`boom`

因此，这个表达式等价于`(boom)==boom`

### ?:	?! 	?=

> 前瞻：exp1(?=exp2) 查找exp2前面的exp1
> 后顾：(?<=exp2)exp1 查找exp2后面的exp1
> 负前瞻：exp1(?!exp2) 查找后面不是exp2的exp1
> 负后顾：(?<!=exp2)exp1 查找前面不是exp2的exp1

#### **举例：**

```JavaScript
"中国人".replace(/(?<=中国)人/, "rr") // 匹配中国人中的人，将其替换为rr，结果为 中国rr
"法国人".replace(/(?<=中国)人/, "rr") // 结果为 法国人，因为人前面不是中国，所以无法匹配到
```

> 要理解**?:**则需要理解捕获分组和非捕获分组的概念：
>
> ()表示捕获分组，()会把每个分组里的匹配的值保存起来，使用$n(n是一个数字，表示第n个捕获组的内容)
>
> (?:)表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来

#### 示例

```JavaScript
var str = '1234567899';
var str2 = '12345678999';
    
var reg = /^(?:([0-9])(?!\1{2})){1,}$/;

reg.test(str); // true
reg.test(str2); // false
```

上例中的效果是，匹配一个数字，但是数字中不允许连续出现`3`次以上的重复数字

### `.`	`\s`	`\S`

首先说下`.`

- 定义是除`\n`以外的任何字符
- 但是，在一些`Chrome`、`Firefox`等内核中，代表`\n`和`\r`以外的字符
- 如果要匹配`.`本身，请用`\.`

再说说**`\s`与`\S`**

- `\s`是匹配所有的空白字符，包括`空白`、`换行`、`tab缩进`等所有空白
- `\S`是指除了空白以外的任何字符（和`.`区别下，`.`里面还多了一部分空白）

那如何匹配所有字符呢？

- `(.|\n)`或者是`[\s\S]`(推荐用法)
- 请不要试图使用`[.\n]`或`[\.\n]`，这种写法只表示小数点或`\n`字符中的一个

### `\b` 单词边界

`\b`匹配单词边界，不匹配任何字符

简单的说，`\b`匹配的位置，一侧是构成单词的字符，另一侧是非单词字符，字符串的开始或结束

而其中单词的判断就是`\w`的匹配范围（正常`a-zA-Z0-9_`，`JS`举例）

注，有一特例，在字符组中`[\b]`表示的是`退格符`

### 特点

- 零宽，即匹配的是位置而不是字符
- 以`\w`来界定单词
- 字符组中是退格符的意思

### 示例

```JavaScript
var str = 'abc_d=efg+hij哈opq%';
    
var reg = /.\b./g;

// ["d=", "g+", "j哈", "q%"]
str.match(reg);
//d和=直接有一个分界；g和+之间；j和哈；q和%
```

### `\`转义

```JavaScript
var str = 'ab\\cd'; // 字符串 ab\cd
var str2 = 'ab\\\\cd'; // 字符串 ab\\cd
    
var reg = /ab\\\\cd/;
var reg2 = new RegExp('ab\\\\cd');

reg.test(str); // false
reg.test(str2); // true

reg2.test(str); // true
reg2.test(str2); // false
```

出现`\`的地方，得多加注意，需要梳理清楚转义逻辑，通过上例可以看到，在正则中出现的`\`和在字符串中出现的`\`意义不一样

- `reg`中，`\`出现在正则中，所以`\\\\`的意思就是匹配`\\`字符串，所以测试`str2`通过，`str`失败
- **`reg2`中，`\`出现在字符串中，所以`\\\\`的意思`\\`，然后构建为正则表达式，最终在正则中是`\\`，也就是匹配`\`字符串本身，所以测试`str`通过，`str2`失败**

### **补充：**同一个正则表达式两次匹配结果不通 

> RegExp 对象的 exec 和 test 方法，以及 String 对象的 match、replace、和 split 方法会修改RegExp 对象的lastIndex 属性
> lastIndex 属性是成功匹配后下一次匹配的开始位置。
>
> 对一个RegExp 对象调用 test 方法之后，如果成功匹配，RegExp对象的lastIndex属性会被设置为匹配结果的结束位置。
> 当对同一个RegExp 对象第二次调用 test 方法时，会从lastIndex属性的位置开始查找，就不是从头开始查找了。
> 如果希望第二次调用 test 方法时，从头开始查找，在调用 test 方法之前要把lastIndex属性设置为0或-1
> 或者每次都重新创建一个RegExp 对象
>
> 另外对于test 方法来说 去掉g（全局匹配）也可以让它每次都从头开始查找 